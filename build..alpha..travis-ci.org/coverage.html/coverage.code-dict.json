{"/home/travis/build/npmtest/node-npmtest-jimp/test.js":"/* istanbul instrument in package npmtest_jimp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jimp/lib.npmtest_jimp.js":"/* istanbul instrument in package npmtest_jimp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jimp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jimp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jimp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jimp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jimp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jimp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jimp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jimp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jimp.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jimp.__dirname + '/lib.npmtest_jimp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jimp/node_modules/jimp/index.js":"if (process.env.ENVIRONMENT !== \"BROWSER\") var FS = require(\"fs\");\nvar PNG = require(\"pngjs\").PNG;\nvar JPEG = require(\"jpeg-js\");\nvar BMP = require(\"bmp-js\");\nvar MIME = require(\"mime\");\nvar TinyColor = require(\"tinycolor2\");\nvar Resize = require(\"./resize.js\");\nvar Resize2 = require(\"./resize2.js\");\nvar StreamToBuffer = require(\"stream-to-buffer\");\nvar ReadChunk = require(\"read-chunk\");\nvar FileType = require(\"file-type\");\nvar PixelMatch = require(\"pixelmatch\");\nvar EXIFParser = require(\"exif-parser\");\nvar ImagePHash = require(\"./phash.js\");\nvar BigNumber = require('bignumber.js');\nvar URLRegEx = require(\"url-regex\");\nvar BMFont = require(\"load-bmfont\");\nvar Path = require(\"path\");\n\nif (process.env.ENVIRONMENT !== \"BROWSER\") {\n    //If we run into electron renderer process, use XHR method instead of Request node module\n    if (process.versions.hasOwnProperty('electron') && process.type === 'renderer' && typeof XMLHttpRequest === \"function\") {\n        var Request = function (url,cb) {\n            var xhr = new XMLHttpRequest();\n            xhr.open( \"GET\", url, true );\n            xhr.responseType = \"arraybuffer\";\n            xhr.onload = function() {\n                if (xhr.status < 400) {\n                    try {\n                        var data = Buffer.from(this.response);\n                    } catch (e) {\n                        return cb(\"Response is not a buffer for url \"+url)\n                    }\n                    cb(null, xhr, data);\n                }\n                else cb(\"HTTP Status \" + xhr.status + \" for url \"+url);\n            };\n            xhr.onerror = function(e) {\n                cb(e);\n            };\n            xhr.send();\n        };\n    } else {\n        var Request = require('request').defaults({ encoding: null });\n    }\n}\n\n// polyfill Promise for Node < 0.12\nvar Promise = global.Promise || require('es6-promise').Promise;\n\n// logging methods\n\nvar chars = 0;\n\nfunction log(msg) {\n    clear();\n    process.stdout.write(msg);\n    chars = msg.length;\n}\n\nfunction clear() {\n    while (chars-- > 0) {\n        process.stdout.write(\"\\b\");\n    }\n}\n\nprocess.on(\"exit\", clear);\n\n// no operation\nfunction noop(){};\n\n// error checking methods\n\nfunction isNodePattern(cb) {\n    if (\"undefined\" == typeof cb) return false;\n    if (\"function\" != typeof cb)\n        throw new Error(\"Callback must be a function\");\n    return true;\n}\n\nfunction throwError(error, cb) {\n    if (\"string\" == typeof error) error = new Error(error);\n    if (\"function\" == typeof cb) return cb.call(this, error);\n    else throw error;\n}\n\n/**\n * Jimp constructor (from a file)\n * @param path a path to the image\n * @param (optional) cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from another Jimp image)\n * @param image a Jimp image to clone\n * @param cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (from a Buffer)\n * @param data a Buffer containing the image data\n * @param cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * Jimp constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param (optional) cb a function to call when the image is parsed to a bitmap\n */\n\nfunction Jimp() {\n    if (\"number\" == typeof arguments[0] && \"number\" == typeof arguments[1]) {\n        // create a new image\n        var w = arguments[0];\n        var h = arguments[1];\n        var cb = arguments[2];\n        \n        if (\"number\" == typeof arguments[2]) {\n            this._background = arguments[2];\n            var cb = arguments[3];\n        }\n\n        if (\"undefined\" == typeof cb) cb = noop;\n        if (\"function\" != typeof cb)\n            return throwError.call(this, \"cb must be a function\", cb);\n\n        this.bitmap = {\n            data: new Buffer(w * h * 4),\n            width: w,\n            height: h\n        };\n\n        for (var i = 0; i < this.bitmap.data.length; i=i+4) {\n            this.bitmap.data.writeUInt32BE(this._background, i);\n        }\n\n        cb.call(this, null, this);\n    } else if (\"object\" == typeof arguments[0] && arguments[0].constructor == Jimp) {\n        // clone an existing Jimp\n        var original = arguments[0];\n        var cb = arguments[1];\n\n        if (\"undefined\" == typeof cb) cb = noop;\n        if (\"function\" != typeof cb)\n            return throwError.call(this, \"cb must be a function\", cb);\n\n        var bitmap = new Buffer(original.bitmap.data.length);\n        original.scan(0, 0, original.bitmap.width, original.bitmap.height, function (x, y, idx) {\n            var data = original.bitmap.data.readUInt32BE(idx, true);\n            bitmap.writeUInt32BE(data, idx, true);\n        });\n\n        this.bitmap = {\n            data: bitmap,\n            width: original.bitmap.width,\n            height: original.bitmap.height\n        };\n\n        this._quality = original._quality;\n        this._deflateLevel = original._deflateLevel;\n        this._deflateStrategy = original._deflateStrategy;\n        this._filterType = original._filterType;\n        this._rgba = original._rgba;\n        this._background = original._background;\n\n        cb.call(this, null, this);\n    } else if (URLRegEx({exact: true}).test(arguments[0])) {\n        // read from a URL\n        var url = arguments[0];\n        var cb = arguments[1];\n        \n        if (\"undefined\" == typeof cb) cb = noop;\n        if (\"function\" != typeof cb)\n            return throwError.call(this, \"cb must be a function\", cb);\n        \n        var that = this;\n        Request(url, function (err, response, data) {\n            if (err) return throwError.call(that, err, cb);\n            if (\"object\" == typeof data && Buffer.isBuffer(data)) {\n                var mime = getMIMEFromBuffer(data);\n                if (\"string\" != typeof mime)\n                    return throwError.call(that, \"Could not find MIME for Buffer <\" + url + \"> (HTTP: \" + response.statusCode + \")\", cb);\n                parseBitmap.call(that, data, mime, cb);\n            } else return throwError.call(that, \"Could not load Buffer from URL <\" + url + \"> (HTTP: \" + response.statusCode + \")\", cb);\n        });\n    } else if (\"string\" == typeof arguments[0]) {\n        // read from a path\n        var path = arguments[0];\n        var cb = arguments[1];\n        \n        if (\"undefined\" == typeof cb) cb = noop;\n        if (\"function\" != typeof cb)\n            return throwError.call(this, \"cb must be a function\", cb);\n\n        var that = this;\n        getMIMEFromPath(path, function (err, mime) {\n            FS.readFile(path, function (err, data) {\n                if (err) return throwError.call(that, err, cb);\n                parseBitmap.call(that, data, mime, cb);\n            });\n        });\n    } else if (\"object\" == typeof arguments[0]) {\n        // read from a buffer\n        var data = arguments[0];\n        var mime = getMIMEFromBuffer(data);\n        var cb = arguments[1];\n\n        if (!Buffer.isBuffer(data))\n            return throwError.call(this, \"data must be a Buffer\", cb);\n        if (\"string\" != typeof mime)\n            return throwError.call(this, \"mime must be a string\", cb);\n        if (\"function\" != typeof cb)\n            return throwError.call(this, \"cb must be a function\", cb);\n\n        parseBitmap.call(this, data, mime, cb);\n    } else {\n        return throwError.call(this, \"No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.\", cb);\n    }\n}\n\n/**\n * Read an image from a file or a Buffer\n * @param src the path to the file or a Buffer containing the file data\n * @param cb (optional) a callback function when the file is read\n * @retuns a promise\n */\nJimp.read = function(src, cb) {\n    var promise = new Promise(\n        function(resolve, reject) {\n            cb = cb || function(err, image) {\n                if (err) reject(err);\n                else resolve(image);\n            }\n            if (\"string\" != typeof src && (\"object\" != typeof src || !Buffer.isBuffer(src)))\n                return throwError.call(this, \"src must be a string or a Buffer\", cb);\n            var img = new Jimp(src, cb);\n        }\n    );\n    return promise;\n}\n\n// MIME type methods\n\nfunction getMIMEFromBuffer(buffer, path) {\n    var fileTypeFromBuffer = FileType(buffer);\n    if (fileTypeFromBuffer) {\n        // If FileType returns something for buffer, then return the mime given\n        return fileTypeFromBuffer.mime;\n    }\n    else if (path) {\n        // If a path is supplied, and FileType yields no results, then retry with MIME\n        // Path can be either a file path or a url\n        return MIME.lookup(path)\n    } else {\n        return null;\n    }\n}\n\n// gets a MIME type of a file from the path to it\nfunction getMIMEFromPath(path, cb) {\n    ReadChunk(path, 0, 262, function (err, buffer) {\n        if (err) {\n            cb(null, \"\");\n        } else {\n            var fileType = FileType(buffer);\n            return cb && cb(null, fileType && fileType.mime || \"\");\n        }\n    });\n}\n\n//=> {ext: 'png', mime: 'image/png'}\n\n// parses a bitmap from the constructor to the JIMP bitmap property\nfunction parseBitmap(data, mime, cb) {\n    var that = this;\n    this._originalMime = mime;\n\n    switch (mime.toLowerCase()) {\n        case Jimp.MIME_PNG:\n            var png = new PNG();\n            png.parse(data, function(err, data) {\n                if (err) return throwError.call(that, err, cb);\n                that.bitmap = {\n                    data: new Buffer(data.data),\n                    width: data.width,\n                    height: data.height\n                };\n                return cb.call(that, null, that);\n            });\n            break;\n\n        case Jimp.MIME_JPEG:\n            try {\n                this.bitmap = JPEG.decode(data);\n                exifRotate(this, data); // EXIF data\n                return cb.call(this, null, this);\n            } catch(err) {\n                return cb.call(this, err, this);\n            }\n\n        case Jimp.MIME_BMP:\n            this.bitmap = BMP.decode(data);\n            return cb.call(this, null, this);\n\n        default:\n            return throwError.call(this, \"Unsupported MIME type: \" + mime, cb);\n    }\n}\n\n/*\n * Automagically rotates a JPEG image based on its EXIF data\n * @params image a Jimp image\n * @params buffer a buffer array of the raw JPEG data\n * @returns nothing\n */\nfunction exifRotate(image, buffer) {\n    var exif;\n    try {\n        exif = EXIFParser.create(buffer).parse();\n    } catch (err) {\n        return; // meh\n    }\n    if (!exif || !exif.tags || !exif.tags.Orientation) return;\n    switch (exif.tags.Orientation) {\n        case 1: // Horizontal (normal)\n            // do nothing\n            break;\n        case 2: // Mirror horizontal\n            image.mirror(true, false);\n            break;\n        case 3: // Rotate 180\n            image.rotate(180);\n            break;\n        case 4: // Mirror vertical\n            image.mirror(false, true);\n            break;\n        case 5: // Mirror horizontal and rotate 270 CW\n            image.mirror(true, false).rotate(270);\n            break;\n        case 6: // Rotate 90 CW\n            image.rotate(90);\n            break;\n        case 7: // Mirror horizontal and rotate 90 CW\n            image.mirror(true, false).rotate(90);\n            break;\n        case 8: // Rotate 270 CW\n            image.rotate(270);\n            break;\n    }\n}\n\n// used to auto resizing etc.\nJimp.AUTO = -1;\n\n// supported mime types\nJimp.MIME_PNG = \"image/png\";\nJimp.MIME_JPEG = \"image/jpeg\";\nJimp.MIME_BMP = \"image/bmp\";\n\n// PNG filter types\nJimp.PNG_FILTER_AUTO = -1;\nJimp.PNG_FILTER_NONE = 0;\nJimp.PNG_FILTER_SUB = 1;\nJimp.PNG_FILTER_UP = 2;\nJimp.PNG_FILTER_AVERAGE = 3;\nJimp.PNG_FILTER_PAETH = 4;\n\nJimp.RESIZE_NEAREST_NEIGHBOR = 'nearestNeighbor';\nJimp.RESIZE_BILINEAR = 'bilinearInterpolation';\nJimp.RESIZE_BICUBIC = 'bicubicInterpolation';\nJimp.RESIZE_HERMITE = 'hermiteInterpolation';\nJimp.RESIZE_BEZIER = 'bezierInterpolation';\n\n// Align modes for cover, contain, bit masks\nJimp.HORIZONTAL_ALIGN_LEFT = 1;\nJimp.HORIZONTAL_ALIGN_CENTER = 2;\nJimp.HORIZONTAL_ALIGN_RIGHT = 4;\n\nJimp.VERTICAL_ALIGN_TOP = 8;\nJimp.VERTICAL_ALIGN_MIDDLE = 16;\nJimp.VERTICAL_ALIGN_BOTTOM = 32;\n\n// Font locations\nJimp.FONT_SANS_8_BLACK = Path.join(__dirname, \"fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt\");\nJimp.FONT_SANS_16_BLACK = Path.join(__dirname, \"fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt\");\nJimp.FONT_SANS_32_BLACK = Path.join(__dirname, \"fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt\");\nJimp.FONT_SANS_64_BLACK = Path.join(__dirname, \"fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt\");\nJimp.FONT_SANS_128_BLACK = Path.join(__dirname, \"fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt\");\n\nJimp.FONT_SANS_8_WHITE = Path.join(__dirname, \"fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt\");\nJimp.FONT_SANS_16_WHITE = Path.join(__dirname, \"fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt\");\nJimp.FONT_SANS_32_WHITE = Path.join(__dirname, \"fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt\");\nJimp.FONT_SANS_64_WHITE = Path.join(__dirname, \"fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt\");\nJimp.FONT_SANS_128_WHITE = Path.join(__dirname, \"fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt\");\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param r the red value (0-255)\n * @param g the green value (0-255)\n * @param b the blue value (0-255)\n * @param a the alpha value (0-255)\n * @param cb (optional) A callback for when complete\n * @returns an single integer colour value\n */\nJimp.rgbaToInt = function(r, g, b, a, cb){\n    if (\"number\" != typeof r || \"number\" != typeof g || \"number\" != typeof b || \"number\" != typeof a)\n        return throwError.call(this, \"r, g, b and a must be numbers\", cb);\n    if (r < 0 || r > 255)\n        return throwError.call(this, \"r must be between 0 and 255\", cb);\n    if (g < 0 || g > 255)\n        throwError.call(this, \"g must be between 0 and 255\", cb);\n    if (b < 0 || b > 255)\n        return throwError.call(this, \"b must be between 0 and 255\", cb);\n    if (a < 0 || a > 255)\n        return throwError.call(this, \"a must be between 0 and 255\", cb);\n    \n    var i = (r * Math.pow(256, 3)) + (g * Math.pow(256, 2)) + (b *  Math.pow(256, 1)) + (a * Math.pow(256, 0));\n    \n    if (isNodePattern(cb)) return cb.call(this, null, i);\n    else return i;\n}\n\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)\n * @param cb (optional) A callback for when complete\n * @returns an object with the properties r, g, b and a representing RGBA values\n */\nJimp.intToRGBA = function(i, cb){\n    if (\"number\" != typeof i)\n        return throwError.call(this, \"i must be a number\", cb);\n    \n    var rgba = {}\n    rgba.r = Math.floor(i / Math.pow(256, 3));\n    rgba.g = Math.floor((i - (rgba.r * Math.pow(256, 3))) / Math.pow(256, 2));\n    rgba.b = Math.floor((i - (rgba.r * Math.pow(256, 3)) - (rgba.g * Math.pow(256, 2))) / Math.pow(256, 1));\n    rgba.a = Math.floor((i - (rgba.r * Math.pow(256, 3)) - (rgba.g * Math.pow(256, 2)) - (rgba.b * Math.pow(256, 1))) / Math.pow(256, 0));\n    \n    if (isNodePattern(cb)) return cb.call(this, null, rgba);\n    else return rgba;\n}\n\n\n/**\n * Limits a number to between 0 or 255\n * @param n a number\n * @returns the number limited to between 0 or 255\n */\nJimp.limit255 = function(n) {\n    n = Math.max(n, 0);\n    n = Math.min(n, 255);\n    return n;\n}\n\n\n/**\n * Diffs two images and returns\n * @param img1 a Jimp image to compare\n * @param img2 a Jimp image to compare\n * @param (optional) threshold a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)\n * @returns an object { percent: percent similar, diff: a Jimp image highlighting differences }\n */\nJimp.diff = function (img1, img2, threshold) {\n    if (\"object\" != typeof img1 || img1.constructor != Jimp || \"object\" != typeof img2 || img2.constructor != Jimp)\n        return throwError.call(this, \"img1 and img2 must be an Jimp images\");\n\n    if (img1.bitmap.width != img2.bitmap.width || img1.bitmap.height != img2.bitmap.height) {\n        switch (img1.bitmap.width * img1.bitmap.height > img2.bitmap.width * img2.bitmap.height) {\n            case true: // img1 is bigger\n                img1 = img1.clone().resize(img2.bitmap.width, img2.bitmap.height);\n                break;\n            default:\n                // img2 is bigger (or they are the same in area)\n                img2 = img2.clone().resize(img1.bitmap.width, img1.bitmap.height);\n                break;\n        }\n    }\n    \n    threshold = threshold || 0.1;\n    if (\"number\" != typeof threshold || threshold < 0 || threshold > 1)\n        return throwError.call(this, \"threshold must be a number between 0 and 1\");\n\n    var diff = new Jimp(img1.bitmap.width, img1.bitmap.height, 0xFFFFFFFF);\n\n    var numDiffPixels = PixelMatch(\n        img1.bitmap.data,\n        img2.bitmap.data,\n        diff.bitmap.data,\n        diff.bitmap.width,\n        diff.bitmap.height,\n        {threshold: threshold}\n    );\n    \n    return {\n        percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),\n        image: diff\n    };\n}\n\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param img1 a Jimp image to compare\n * @param img2 a Jimp image to compare\n * @returns a number ranging from 0 to 1, 0 means they are believed to be identical\n */\nJimp.distance = function (img1, img2) {\n    var phash = new ImagePHash();\n    var hash1 = phash.getHash(img1);\n    var hash2 = phash.getHash(img2);\n    return phash.distance(hash1, hash2);\n}\n\n\n// An object representing a bitmap in memory, comprising:\n//  - data: a buffer of the bitmap data\n//  - width: the width of the image in pixels\n//  - height: the height of the image in pixels\nJimp.prototype.bitmap = {\n    data: null,\n    width: null,\n    height: null\n};\n\n// The quality to be used when saving JPEG images\nJimp.prototype._quality = 100;\nJimp.prototype._deflateLevel = 9;\nJimp.prototype._deflateStrategy = 3;\nJimp.prototype._filterType = Jimp.PNG_FILTER_AUTO;\n\n// Whether PNGs will be exported as RGB or RGBA\nJimp.prototype._rgba = true;\n\n// Default colour to use for new pixels\nJimp.prototype._background = 0x00000000;\n\n/**\n * Creates a new image that is a clone of this one.\n * @param cb (optional) A callback for when complete\n * @returns the new image\n */\nJimp.prototype.clone = function (cb) {\n    var clone = new Jimp(this);\n\n    if (isNodePattern(cb)) return cb.call(clone, null, clone);\n    else return clone;\n};\n\n/**\n * Sets the quality of the image when saving as JPEG format (default is 100)\n * @param n The quality to use 0-100\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.quality = function (n, cb) {\n    if (\"number\" != typeof n)\n        return throwError.call(this, \"n must be a number\", cb);\n    if (n < 0 || n > 100)\n        return throwError.call(this, \"n must be a number 0 - 100\", cb);\n\n    this._quality = Math.round(n);\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Sets the deflate level used when saving as PNG format (default is 9)\n * @param l Deflate level to use 0-9. 0 is no compression. 9 (default) is maximum compression.\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.deflateLevel = function (l, cb) {\n    if (\"number\" != typeof l)\n        return throwError.call(this, \"l must be a number\", cb);\n    if (l < 0 || l > 9)\n        return throwError.call(this, \"l must be a number 0 - 9\", cb);\n\n    this._deflateLevel = Math.round(l);\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Sets the deflate strategy used when saving as PNG format (default is 3)\n * @param s Deflate strategy to use 0-3.\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.deflateStrategy = function (s, cb) {\n    if (\"number\" != typeof s)\n        return throwError.call(this, \"s must be a number\", cb);\n    if (s < 0 || s > 3)\n        return throwError.call(this, \"s must be a number 0 - 3\", cb);\n\n    this._deflateStrategy = Math.round(s);\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Sets the filter type used when saving as PNG format (default is automatic filters)\n * @param f The quality to use -1-4.\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.filterType = function (f, cb) {\n    if (\"number\" != typeof f)\n        return throwError.call(this, \"n must be a number\", cb);\n    if (f < -1 || f > 4)\n        return throwError.call(this, \"n must be -1 (auto) or a number 0 - 4\", cb);\n\n    this._filterType = Math.round(f);\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)\n * @param bool A Boolean, true to use RGBA or false to use RGB\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.rgba = function (bool, cb) {\n    if (\"boolean\" != typeof bool)\n        return throwError.call(this, \"bool must be a boolean, true for RGBA or false for RGB\", cb);\n\n    this._rgba = bool;\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)\n * @param b A Boolean, true to use RGBA or false to use RGB\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.background = function (hex, cb) {\n    if (\"number\" != typeof hex)\n        return throwError.call(this, \"hex must be a hexadecimal rgba value\", cb);\n\n    this._background = hex;\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Scanes through a region of the bitmap, calling a function for each pixel.\n * @param x the x coordinate to begin the scan at\n * @param y the y coordiante to begin the scan at\n * @param w the width of the scan region\n * @param h the height of the scan region\n * @param f a function to call on even pixel; the (x, y) position of the pixel\n * and the index of the pixel in the bitmap buffer are passed to the function\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.scan = function (x, y, w, h, f, cb) {\n    if (\"number\" != typeof x || \"number\" != typeof y)\n        return throwError.call(this, \"x and y must be numbers\", cb);\n    if (\"number\" != typeof w || \"number\" != typeof h)\n        return throwError.call(this, \"w and h must be numbers\", cb);\n    if (\"function\" != typeof f)\n        return throwError.call(this, \"f must be a function\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n\n    for (var _y = y; _y < (y + h); _y++) {\n        for (var _x = x; _x < (x + w); _x++) {\n            var idx = (this.bitmap.width * _y + _x) << 2;\n            f.call(this, _x, _y, idx);\n        }\n    }\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Returns the offset of a pixel in the bitmap buffer\n * @param x the x coordinate\n * @param y the y coordinate\n * @param (optional) cb a callback for when complete\n * @returns the index of the pixel or -1 if not found\n*/\nJimp.prototype.getPixelIndex = function (x, y, cb) {\n    if (\"number\" != typeof x || \"number\" != typeof y)\n        return throwError.call(this, \"x and y must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    var i = (this.bitmap.width * y + x) << 2;\n\n    // if out of bounds index is -1\n    if (x < 0 || x > this.bitmap.width) i = -1;\n    if (y < 0 || y > this.bitmap.height) i = -1;\n\n    if (isNodePattern(cb)) return cb.call(this, null, i);\n    else return i;\n};\n\n/**\n * Returns the hex colour value of a pixel\n * @param x the x coordinate\n * @param y the y coordinate\n * @param (optional) cb a callback for when complete\n * @returns the index of the pixel or -1 if not found\n*/\nJimp.prototype.getPixelColor = Jimp.prototype.getPixelColour = function (x, y, cb) {\n    if (\"number\" != typeof x || \"number\" != typeof y)\n        return throwError.call(this, \"x and y must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    \n    var idx = this.getPixelIndex(x, y);\n    var hex = this.bitmap.data.readUInt32BE(idx);\n    \n    if (isNodePattern(cb)) return cb.call(this, null, hex);\n    else return hex;\n};\n\n/**\n * Returns the hex colour value of a pixel\n * @param x the x coordinate\n * @param y the y coordinate\n * @param (optional) cb a callback for when complete\n * @returns the index of the pixel or -1 if not found\n*/\nJimp.prototype.setPixelColor = Jimp.prototype.setPixelColour = function (hex, x, y, cb) {\n    if (\"number\" != typeof hex || \"number\" != typeof x || \"number\" != typeof y)\n        return throwError.call(this, \"hex, x and y must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    \n    var idx = this.getPixelIndex(x, y);\n    this.bitmap.data.writeUInt32BE(hex, idx, true);\n    \n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n\n// an array storing the maximum string length of hashes at various bases\nvar maxHashLength = [];\nfor (var i = 0; i < 65; i++) {\n    var l = (i > 1) ? (new BigNumber(Array(64 + 1).join(\"1\"), 2)).toString(i) : NaN;\n    maxHashLength.push(l.length);\n}\n\n/**\n * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>.\n * @param base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimaal, 16 is hex, 64 is base 64). Defaults to 64.\n * @param (optional) cb a callback for when complete\n * @returns a string representing the hash\n */\nJimp.prototype.hash = function(base, cb){\n    base = base || 64;\n    if (\"function\" == typeof base) {\n        cb = base;\n        base = 64;\n    }\n    if (\"number\" != typeof base)\n        return throwError.call(this, \"base must be a number\", cb);\n    if (base < 2 || base > 64)\n        return throwError.call(this, \"base must be a number between 2 and 64\", cb);\n    \n    var hash = (new ImagePHash()).getHash(this);\n    hash = (new BigNumber(hash, 2)).toString(base);\n    \n    while (hash.length < maxHashLength[base]) {\n        hash = \"0\" + hash; // pad out with leading zeros\n    }\n    \n    if (isNodePattern(cb)) return cb.call(this, null, hash);\n    else return hash;\n}\n\n\n/**\n * Crops the image at a given point to a give size\n * @param x the x coordinate to crop form\n * @param y the y coordiante to crop form\n * @param w the width of the crop region\n * @param h the height of the crop region\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.crop = function (x, y, w, h, cb) {\n    if (\"number\" != typeof x || \"number\" != typeof y)\n        return throwError.call(this, \"x and y must be numbers\", cb);\n    if (\"number\" != typeof w || \"number\" != typeof h)\n        return throwError.call(this, \"w and h must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n\n    var bitmap = new Buffer(this.bitmap.data.length);\n    var offset = 0;\n    this.scan(x, y, w, h, function (x, y, idx) {\n        var data = this.bitmap.data.readUInt32BE(idx, true);\n        bitmap.writeUInt32BE(data, offset, true);\n        offset += 4;\n    });\n\n    this.bitmap.data = new Buffer(bitmap);\n    this.bitmap.width = w;\n    this.bitmap.height = h;\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Autocrop same color borders from this image\n * @param (optional) tolerance:      a percent value of tolerance for\n *                                   pixels color difference (default: 0.0002%)\n * @param (optional) cropOnlyFrames: flag to crop only real frames:\n *                                   all 4 sides of the image must have some border (default: true)\n * @param (optional) cb:             a callback for when complete (default: no callback)\n * @returns this                     for chaining of methods\n */\nJimp.prototype.autocrop = function() {\n    var w = this.bitmap.width;\n    var h = this.bitmap.height;\n    var minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n    var cb; // callback\n    var tolerance = 0.0002; // percent of color difference tolerance (default value)\n    var cropOnlyFrames = true; // flag to force cropping only if the image has a real \"frame\"\n                               // i.e. all 4 sides have some border (default value)\n\n    // parse arguments\n    for (var a = 0, len = arguments.length; a < len; a++) {\n        if (\"number\" == typeof arguments[a]) { // tolerance value passed\n            tolerance = arguments[a];\n        }\n        if (\"boolean\" == typeof arguments[a]) { // tolerance value passed\n            cropOnlyFrames = arguments[a];\n        }\n        if (\"function\" == typeof arguments[a]) { // callback value passed\n            cb = arguments[a];\n        }\n    }\n\n    /**\n     * North and East borders must be of the same color as the top left pixel, to be cropped.\n     * South and West borders must be of the same color as the bottom right pixel, to be cropped.\n     * It should be possible to crop borders each with a different color,\n     * but since there are many ways for corners to intersect, it would\n     * introduce unnecessary complexity to the algorithm.\n     */\n\n    // scan each side for same color borders\n    var colorTarget = this.getPixelColor(0, 0); // top left pixel color is the target color\n                                                // for north and east sides\n    var northPixelsToCrop = 0;\n    var eastPixelsToCrop = 0;\n    var southPixelsToCrop = 0;\n    var westPixelsToCrop = 0;\n\n    var rgba1 = Jimp.intToRGBA(colorTarget);\n\n    north: // north side (scan rows from north to south)\n    for (var y = 0; y < h - minPixelsPerSide; y++) {\n        for (var x = 0; x < w; x++) {\n            var colorXY = this.getPixelColor(x, y);\n            var rgba2 = Jimp.intToRGBA(colorXY);\n            var difference =\n                Math.abs(\n                    Math.max((rgba1.r - rgba2.r) ^ 2, (rgba1.r - rgba2.r - rgba1.a + rgba2.a) ^ 2) +\n                    Math.max((rgba1.g - rgba2.g) ^ 2, (rgba1.g - rgba2.g - rgba1.a + rgba2.a) ^ 2) +\n                    Math.max((rgba1.b - rgba2.b) ^ 2, (rgba1.b - rgba2.b - rgba1.a + rgba2.a) ^ 2)\n                ) / (256 * 256 * 3);\n\n            if (difference > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break north;\n            }\n        }\n        // this row contains all pixels with the same color: increment this side pixels to crop\n        northPixelsToCrop++;\n    }\n\n    east: // east side (scan columns from east to west)\n    for (var x = 0; x < w - minPixelsPerSide; x++) {\n        for (var y = 0 + northPixelsToCrop; y < h; y++) {\n            var colorXY = this.getPixelColor(x, y);\n            var rgba2 = Jimp.intToRGBA(colorXY);\n            var difference =\n                Math.abs(\n                    Math.max((rgba1.r - rgba2.r) ^ 2, (rgba1.r - rgba2.r - rgba1.a + rgba2.a) ^ 2) +\n                    Math.max((rgba1.g - rgba2.g) ^ 2, (rgba1.g - rgba2.g - rgba1.a + rgba2.a) ^ 2) +\n                    Math.max((rgba1.b - rgba2.b) ^ 2, (rgba1.b - rgba2.b - rgba1.a + rgba2.a) ^ 2)\n                ) / (256 * 256 * 3);\n\n            if (difference > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break east;\n            }\n        }\n        // this column contains all pixels with the same color: increment this side pixels to crop\n        eastPixelsToCrop++;\n    }\n\n    colorTarget = this.getPixelColor(w - 1, h - 1); // bottom right pixel color is the target color\n                                                    // for south and west sides\n    south: // south side (scan rows from south to north)\n    for (var y = h - 1; y >= 0 + northPixelsToCrop + minPixelsPerSide; y--) {\n        for (var x = w - eastPixelsToCrop - 1; x >= 0; x--) {\n            var colorXY = this.getPixelColor(x, y);\n            var rgba2 = Jimp.intToRGBA(colorXY);\n            var difference =\n                Math.abs(\n                    Math.max((rgba1.r - rgba2.r) ^ 2, (rgba1.r - rgba2.r - rgba1.a + rgba2.a) ^ 2) +\n                    Math.max((rgba1.g - rgba2.g) ^ 2, (rgba1.g - rgba2.g - rgba1.a + rgba2.a) ^ 2) +\n                    Math.max((rgba1.b - rgba2.b) ^ 2, (rgba1.b - rgba2.b - rgba1.a + rgba2.a) ^ 2)\n                ) / (256 * 256 * 3);\n\n            if (difference > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break south;\n            }\n        }\n        // this row contains all pixels with the same color: increment this side pixels to crop\n        southPixelsToCrop++;\n    }\n\n    west: // west side (scan columns from west to east)\n    for (var x = w - 1; x >= 0 + eastPixelsToCrop + minPixelsPerSide; x--) {\n        for (var y = h - 1; y >= 0 + northPixelsToCrop; y--) {\n            var colorXY = this.getPixelColor(x, y);\n            var rgba2 = Jimp.intToRGBA(colorXY);\n            var difference =\n                Math.abs(\n                    Math.max((rgba1.r - rgba2.r) ^ 2, (rgba1.r - rgba2.r - rgba1.a + rgba2.a) ^ 2) +\n                    Math.max((rgba1.g - rgba2.g) ^ 2, (rgba1.g - rgba2.g - rgba1.a + rgba2.a) ^ 2) +\n                    Math.max((rgba1.b - rgba2.b) ^ 2, (rgba1.b - rgba2.b - rgba1.a + rgba2.a) ^ 2)\n                ) / (256 * 256 * 3);\n\n            if (difference > tolerance) {\n                // this pixel is too distant from the first one: abort this side scan\n                break west;\n            }\n        }\n        // this column contains all pixels with the same color: increment this side pixels to crop\n        westPixelsToCrop++;\n    }\n\n    // safety checks\n    var widthOfPixelsToCrop = w - (westPixelsToCrop + eastPixelsToCrop);\n    widthOfPixelsToCrop >= 0 ? widthOfPixelsToCrop : 0;\n    var heightOfPixelsToCrop = h - (southPixelsToCrop + northPixelsToCrop);\n    heightOfPixelsToCrop >= 0 ? heightOfPixelsToCrop : 0;\n\n    // decide if a crop is needed\n    var doCrop = false;\n    if (cropOnlyFrames) { // crop image if all sides should be cropped\n        doCrop = (\n            eastPixelsToCrop !== 0 &&\n            northPixelsToCrop !== 0 &&\n            westPixelsToCrop !== 0 &&\n            southPixelsToCrop !== 0\n        );\n    } else { // crop image if at least one side should be cropped\n        doCrop = (\n            eastPixelsToCrop !== 0 ||\n            northPixelsToCrop !== 0 ||\n            westPixelsToCrop !== 0 ||\n            southPixelsToCrop !== 0\n        );\n    }\n\n    if (doCrop) { // do the real crop\n       this.crop(\n           eastPixelsToCrop,\n           northPixelsToCrop,\n           widthOfPixelsToCrop,\n           heightOfPixelsToCrop\n       );\n    }\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Blits a source image on to this image\n * @param src the source Jimp instance\n * @param x the x position to blit the image\n * @param y the y position to blit the image\n * @param srcx (optional) the x position from which to crop the source image\n * @param srcy (optional) the y position from which to crop the source image\n * @param srcw (optional) the width to which to crop the source image\n * @param srch (optional) the height to which to crop the source image\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n*/\nJimp.prototype.blit = function (src, x, y, srcx, srcy, srcw, srch, cb) {\n    if (\"object\" != typeof src || src.constructor != Jimp)\n        return throwError.call(this, \"The source must be a Jimp image\", cb);\n    if (\"number\" != typeof x || \"number\" != typeof y)\n        return throwError.call(this, \"x and y must be numbers\", cb);\n\n    if (\"function\" == typeof srcx) {\n        cb = srcx;\n        srcx = 0;\n        srcy = 0;\n        srcw = src.bitmap.width;\n        srch = src.bitmap.height;\n    } else if (typeof srcx == typeof srcy && typeof srcy == typeof srcw && typeof srcw == typeof srch) {\n        srcx = srcx || 0;\n        srcy = srcy || 0;\n        srcw = srcw || src.bitmap.width;\n        srch = srch || src.bitmap.height;\n    } else {\n        return throwError.call(this, \"srcx, srcy, srcw, srch must be numbers\", cb);\n    }\n\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    // round input\n    srcx = Math.round(srcx);\n    srcy = Math.round(srcy);\n    srcw = Math.round(srcw);\n    srch = Math.round(srch);\n\n    var that = this;\n    src.scan(srcx, srcy, srcw, srch, function(sx, sy, idx) {\n        var dstIdx = that.getPixelIndex(x+sx-srcx, y+sy-srcy);\n        that.bitmap.data[dstIdx] = this.bitmap.data[idx];\n        that.bitmap.data[dstIdx+1] = this.bitmap.data[idx+1];\n        that.bitmap.data[dstIdx+2] = this.bitmap.data[idx+2];\n        that.bitmap.data[dstIdx+3] = this.bitmap.data[idx+3];\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.\n * @param src the source Jimp instance\n * @param x the x position to blit the image\n * @param y the y position to blit the image\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n*/\nJimp.prototype.mask = function (src, x, y, cb) {\n    if (\"object\" != typeof src || src.constructor != Jimp)\n        return throwError.call(this, \"The source must be a Jimp image\", cb);\n    if (\"number\" != typeof x || \"number\" != typeof y)\n        return throwError.call(this, \"x and y must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    var that = this;\n    src.scan(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {\n        var dstIdx = that.getPixelIndex(x+sx, y+sy);\n        var avg = (this.bitmap.data[idx+0] + this.bitmap.data[idx+1] + this.bitmap.data[idx+2]) / 3;\n        that.bitmap.data[dstIdx+3] *= avg / 255;\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param src the source Jimp instance\n * @param x the x position to blit the image\n * @param y the y position to blit the image\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n*/\nJimp.prototype.composite = function (src, x, y, cb) {\n    if (\"object\" != typeof src || src.constructor != Jimp)\n        return throwError.call(this, \"The source must be a Jimp image\", cb);\n    if (\"number\" != typeof x || \"number\" != typeof y)\n        return throwError.call(this, \"x and y must be numbers\", cb);\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n\n    var that = this;\n    src.scan(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {\n        // http://stackoverflow.com/questions/7438263/alpha-compositing-algorithm-blend-modes\n        var dstIdx = that.getPixelIndex(x+sx, y+sy);\n        \n        var fg = {\n            r: this.bitmap.data[idx + 0] / 255,\n            g: this.bitmap.data[idx + 1] / 255,\n            b: this.bitmap.data[idx + 2] / 255,\n            a: this.bitmap.data[idx + 3] / 255\n        }\n        \n        var bg = {\n            r: that.bitmap.data[dstIdx + 0] / 255,\n            g: that.bitmap.data[dstIdx + 1] / 255,\n            b: that.bitmap.data[dstIdx + 2] / 255,\n            a: that.bitmap.data[dstIdx + 3] / 255\n        }\n        \n        var a = bg.a + fg.a - bg.a * fg.a;\n        \n        var r = ((fg.r * fg.a) + (bg.r * bg.a) * (1 - fg.a)) / a;\n        var g = ((fg.g * fg.a) + (bg.g * bg.a) * (1 - fg.a)) / a;\n        var b = ((fg.b * fg.a) + (bg.b * bg.a) * (1 - fg.a)) / a;\n        \n        that.bitmap.data[dstIdx + 0] = Jimp.limit255(r * 255);\n        that.bitmap.data[dstIdx + 1] = Jimp.limit255(g * 255);\n        that.bitmap.data[dstIdx + 2] = Jimp.limit255(b * 255);\n        that.bitmap.data[dstIdx + 3] = Jimp.limit255(a * 255);\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Adjusts the brightness of the image\n * @param val the amount to adjust the brightness, a number between -1 and +1\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.brightness = function (val, cb) {\n    if (\"number\" != typeof val)\n        return throwError.call(this, \"val must be numbers\", cb);\n    if (val < -1 || val > +1)\n        return throwError.call(this, \"val must be a number between -1 and +1\", cb);\n\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        if (val < 0.0)  {\n            this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val);\n            this.bitmap.data[idx+1] = this.bitmap.data[idx+1] * (1 + val);\n            this.bitmap.data[idx+2] = this.bitmap.data[idx+2] * (1 + val);\n        } else {\n            this.bitmap.data[idx] = this.bitmap.data[idx] + ((255 - this.bitmap.data[idx]) * val);\n            this.bitmap.data[idx+1] = this.bitmap.data[idx+1] + ((255 - this.bitmap.data[idx+1]) * val);\n            this.bitmap.data[idx+2] = this.bitmap.data[idx+2] + ((255 - this.bitmap.data[idx+2]) * val);\n        }\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Adjusts the contrast of the image\n * val the amount to adjust the contrast, a number between -1 and +1\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.contrast = function (val, cb) {\n    if (\"number\" != typeof val)\n        return throwError.call(this, \"val must be numbers\", cb);\n    if (val < -1 || val > +1)\n        return throwError.call(this, \"val must be a number between -1 and +1\", cb);\n\n    function adjust(value) {\n        if (val < 0) {\n            var x = (value > 127) ? 1 - value / 255 : value / 255;\n            if (x < 0) x = 0;\n            x = 0.5 * Math.pow (x * 2, 1 + val);\n            return (value > 127) ? (1.0 - x) * 255 : x * 255;\n        } else {\n            var x = (value > 127) ? 1 - value / 255 : value / 255;\n            if (x < 0) x = 0;\n            x = 0.5 * Math.pow (2 * x, ((val == 1) ? 127 : 1 / (1 - val)));\n            return (value > 127) ? (1 - x) * 255 : x * 255;\n        }\n    }\n\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);\n        this.bitmap.data[idx+1] = adjust(this.bitmap.data[idx+1]);\n        this.bitmap.data[idx+2] = adjust(this.bitmap.data[idx+2]);\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n\n/**\n * Apply a posterize effect\n * val the amount to adjust the contrast, minimum threshold is two\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.posterize = function (n, cb) {\n    if (\"number\" != typeof n)\n        return throwError.call(this, \"n must be numbers\", cb);\n\n    if (n < 2) n = 2; // minumum of 2 levels\n\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx] = (Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1)) * 255;\n        this.bitmap.data[idx+1] = (Math.floor(this.bitmap.data[idx+1] / 255 * (n - 1)) / (n - 1)) * 255;\n        this.bitmap.data[idx+2] = (Math.floor(this.bitmap.data[idx+2] / 255 * (n - 1)) / (n - 1)) * 255;\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Get an image's histogram\n * @return {object} An object with an array of color occurence counts for each channel (r,g,b)\n */\nfunction histogram() {\n    var histogram = {\n        r: new Array(256).fill(0),\n        g: new Array(256).fill(0),\n        b: new Array(256).fill(0)\n    };\n\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, index){\n        histogram.r[this.bitmap.data[index+0]]++;\n        histogram.g[this.bitmap.data[index+1]]++;\n        histogram.b[this.bitmap.data[index+2]]++;\n    });\n\n    return histogram;\n}\n\n/**\n * Normalizes the image\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.normalize = function (cb) {\n    var h = histogram.call(this);\n\n    /**\n     * Normalize values\n     * @param  {integer} value Pixel channel value.\n     * @param  {integer} min   Minimum value for channel\n     * @param  {integer} max   Maximum value for channel\n     * @return {integer}\n     */\n    var normalize = function (value, min, max) {\n        return (value - min) * 255 / (max - min);\n    };\n\n    var getBounds = function (histogramChannel) {\n        return [\n            histogramChannel.findIndex(function(value) {\n                return value > 0;\n            }),\n            255 - histogramChannel.slice().reverse().findIndex(function(value) {\n                return value > 0;\n            })\n        ];\n    };\n\n    // store bounds (minimum and maximum values)\n    var bounds = {\n        r: getBounds(h.r),\n        g: getBounds(h.g),\n        b: getBounds(h.b)\n    };\n\n    // apply value transformations\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var r = this.bitmap.data[idx + 0];\n        var g = this.bitmap.data[idx + 1];\n        var b = this.bitmap.data[idx + 2];\n\n        this.bitmap.data[idx + 0] = normalize(r, bounds.r[0], bounds.r[1]);\n        this.bitmap.data[idx + 1] = normalize(g, bounds.g[0], bounds.g[1]);\n        this.bitmap.data[idx + 2] = normalize(b, bounds.b[0], bounds.b[1]);\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n}\n\n\n/**\n * Inverts the image\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.invert = function (cb) {\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx] = 255 - this.bitmap.data[idx];\n        this.bitmap.data[idx+1] = 255 - this.bitmap.data[idx+1];\n        this.bitmap.data[idx+2] = 255 - this.bitmap.data[idx+2];\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Flip the image horizontally\n * @param horizontal a Boolean, if true the image will be flipped horizontally\n * @param vertical a Boolean, if true the image will be flipped vertically\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.mirror = Jimp.prototype.flip = function (horizontal, vertical, cb) {\n    if (\"boolean\" != typeof horizontal || \"boolean\" != typeof vertical)\n        return throwError.call(this, \"horizontal and vertical must be Booleans\", cb);\n\n    var bitmap = new Buffer(this.bitmap.data.length);\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var _x = (horizontal) ? (this.bitmap.width - 1 - x) : x;\n        var _y = (vertical) ? (this.bitmap.height - 1 - y) : y;\n        var _idx = (this.bitmap.width * _y + _x) << 2;\n\n        var data = this.bitmap.data.readUInt32BE(idx, true);\n        bitmap.writeUInt32BE(data, _idx, true);\n    });\n\n    this.bitmap.data = new Buffer(bitmap);\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Applies a true Gaussian blur to the image (warning: this is VERY slow)\n * @param r the pixel radius of the blur\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.gaussian = function (r, cb) {\n    // http://blog.ivank.net/fastest-gaussian-blur.html\n    if (\"number\" != typeof r)\n        return throwError.call(this, \"r must be a number\", cb);\n    if (r < 1)\n        return throwError.call(this, \"r must be greater than 0\", cb);\n\n    var rs = Math.ceil(r * 2.57); // significant radius\n\n    for (var y = 0; y < this.bitmap.height; y++) {\n        log(\"Gaussian: \" + Math.round(y / this.bitmap.height * 100) + \"%\");\n        for (var x = 0; x < this.bitmap.width; x++) {\n            var red = 0;\n            var green = 0;\n            var blue = 0;\n            var alpha = 0;\n            var wsum = 0;\n            for (var iy = y - rs; iy < y + rs + 1; iy++) {\n                for (var ix = x - rs; ix < x + rs + 1; ix++) {\n                    var x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix));\n                    var y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy));\n                    var dsq = (ix - x) * (ix - x) + (iy - y) * (iy - y);\n                    var wght = Math.exp( -dsq / (2*r*r) ) / (Math.PI*2*r*r);\n                    var idx = (y1 * this.bitmap.width + x1) << 2;\n                    red += this.bitmap.data[idx] * wght;\n                    green += this.bitmap.data[idx+1] * wght;\n                    blue += this.bitmap.data[idx+2] * wght;\n                    alpha += this.bitmap.data[idx+3] * wght;\n                    wsum += wght;\n                }\n                var idx = (y * this.bitmap.width + x) << 2;\n                this.bitmap.data[idx] = Math.round( red / wsum);\n                this.bitmap.data[idx+1] = Math.round( green / wsum);\n                this.bitmap.data[idx+2] = Math.round( blue / wsum);\n                this.bitmap.data[idx+3] = Math.round( alpha / wsum);\n            }\n        }\n    }\n\n    clear(); // clear the log\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/*\n    Superfast Blur (0.5)\n    http://www.quasimondo.com/BoxBlurForCanvas/FastBlur.js\n\n    Copyright (c) 2011 Mario Klingemann\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar mul_table = [1,57,41,21,203,34,97,73,227,91,149,62,105,45,39,137,241,107,3,173,39,71,65,238,219,101,187,87,81,151,141,133,249,117,221,209,197,187,177,169,5,153,73,139,133,127,243,233,223,107,103,99,191,23,177,171,165,159,77,149,9,139,135,131,253,245,119,231,224,109,211,103,25,195,189,23,45,175,171,83,81,79,155,151,147,9,141,137,67,131,129,251,123,30,235,115,113,221,217,53,13,51,50,49,193,189,185,91,179,175,43,169,83,163,5,79,155,19,75,147,145,143,35,69,17,67,33,65,255,251,247,243,239,59,29,229,113,111,219,27,213,105,207,51,201,199,49,193,191,47,93,183,181,179,11,87,43,85,167,165,163,161,159,157,155,77,19,75,37,73,145,143,141,35,138,137,135,67,33,131,129,255,63,250,247,61,121,239,237,117,29,229,227,225,111,55,109,216,213,211,209,207,205,203,201,199,197,195,193,48,190,47,93,185,183,181,179,178,176,175,173,171,85,21,167,165,41,163,161,5,79,157,78,154,153,19,75,149,74,147,73,144,143,71,141,140,139,137,17,135,134,133,66,131,65,129,1];\n\nvar shg_table = [0,9,10,10,14,12,14,14,16,15,16,15,16,15,15,17,18,17,12,18,16,17,17,19,19,18,19,18,18,19,19,19,20,19,20,20,20,20,20,20,15,20,19,20,20,20,21,21,21,20,20,20,21,18,21,21,21,21,20,21,17,21,21,21,22,22,21,22,22,21,22,21,19,22,22,19,20,22,22,21,21,21,22,22,22,18,22,22,21,22,22,23,22,20,23,22,22,23,23,21,19,21,21,21,23,23,23,22,23,23,21,23,22,23,18,22,23,20,22,23,23,23,21,22,20,22,21,22,24,24,24,24,24,22,21,24,23,23,24,21,24,23,24,22,24,24,22,24,24,22,23,24,24,24,20,23,22,23,24,24,24,24,24,24,24,23,21,23,22,23,24,24,24,22,24,24,24,23,22,24,24,25,23,25,25,23,24,25,25,24,22,25,25,25,24,23,24,25,25,25,25,25,25,25,25,25,25,25,25,23,25,23,24,25,25,25,25,25,25,25,25,25,24,22,25,25,23,25,25,20,24,25,24,25,25,22,24,25,24,25,24,25,25,24,25,25,25,25,22,25,25,25,24,25,24,25,18];\n\n/**\n * A fast blur algorithm that produces similar effect to a Gausian blur - but MUCH quicker\n * @param r the pixel radius of the blur\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.blur = function (r, cb) {\n    if (\"number\" != typeof r)\n        return throwError.call(this, \"r must be a number\", cb);\n    if (r < 1)\n        return throwError.call(this, \"r must be greater than 0\", cb);\n\n    var rsum, gsum, bsum, asum, x, y, i, p, p1, p2, yp, yi, yw, idx, pa;\n    var wm = this.bitmap.width - 1;\n    var hm = this.bitmap.height - 1;\n    var wh = this.bitmap.width * this.bitmap.height;\n    var rad1 = r + 1;\n\n    var mul_sum = mul_table[r];\n    var shg_sum = shg_table[r];\n\n    var red = [];\n    var green = [];\n    var blue = [];\n    var alpha = [];\n\n    var vmin = [];\n    var vmax = [];\n\n    var iterations = 2;\n    while (iterations-- > 0) {\n        yw = yi = 0;\n\n        for (y = 0; y < this.bitmap.height; y++) {\n            rsum = this.bitmap.data[yw] * rad1;\n            gsum = this.bitmap.data[yw + 1] * rad1;\n            bsum = this.bitmap.data[yw + 2] * rad1;\n            asum = this.bitmap.data[yw + 3] * rad1;\n\n\n            for (i = 1; i <= r; i++) {\n                p = yw + (((i > wm ? wm : i)) << 2);\n                rsum += this.bitmap.data[p++];\n                gsum += this.bitmap.data[p++];\n                bsum += this.bitmap.data[p++];\n                asum += this.bitmap.data[p];\n            }\n\n            for (x = 0; x < this.bitmap.width; x++) {\n                red[yi] = rsum;\n                green[yi] = gsum;\n                blue[yi] = bsum;\n                alpha[yi] = asum;\n\n                if (y == 0) {\n                    vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;\n                    vmax[x] = ((p = x - r) > 0 ? p << 2 : 0);\n                }\n\n                p1 = yw + vmin[x];\n                p2 = yw + vmax[x];\n\n                rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];\n                gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];\n                bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];\n                asum += this.bitmap.data[p1] - this.bitmap.data[p2];\n\n                yi++;\n            }\n            yw += (this.bitmap.width << 2);\n        }\n\n        for (x = 0; x < this.bitmap.width; x++) {\n            yp = x;\n            rsum = red[yp] * rad1;\n            gsum = green[yp] * rad1;\n            bsum = blue[yp] * rad1;\n            asum = alpha[yp] * rad1;\n\n            for (i = 1; i <= r; i++) {\n                yp += (i > hm ? 0 : this.bitmap.width);\n                rsum += red[yp];\n                gsum += green[yp];\n                bsum += blue[yp];\n                asum += alpha[yp];\n            }\n\n            yi = x << 2;\n            for (y = 0; y < this.bitmap.height; y++) {\n\n                this.bitmap.data[yi + 3] = pa = (asum * mul_sum) >>> shg_sum;\n                if (pa > 255) this.bitmap.data[yi + 3] = 255; // normalise alpha\n                if (pa > 0) {\n                    pa = 255 / pa;\n                    this.bitmap.data[yi] = ((rsum * mul_sum) >>> shg_sum) * pa;\n                    this.bitmap.data[yi + 1] = ((gsum * mul_sum) >>> shg_sum) * pa;\n                    this.bitmap.data[yi + 2] = ((bsum * mul_sum) >>> shg_sum) * pa;\n                } else {\n                    this.bitmap.data[yi] = this.bitmap.data[yi + 1] = this.bitmap.data[yi + 2] = 0;\n                }\n                if (x == 0) {\n                    vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width;\n                    vmax[y] = ((p = y - r) > 0 ? p * this.bitmap.width : 0);\n                }\n\n                p1 = x + vmin[y];\n                p2 = x + vmax[y];\n\n                rsum += red[p1] - red[p2];\n                gsum += green[p1] - green[p2];\n                bsum += blue[p1] - blue[p2];\n                asum += alpha[p1] - alpha[p2];\n\n                yi += this.bitmap.width << 2;\n            }\n        }\n    }\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Removes colour from the image using ITU Rec 709 luminance values\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.greyscale = function (cb) {\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var grey = parseInt(.2126 * this.bitmap.data[idx] + .7152 * this.bitmap.data[idx+1] + .0722 * this.bitmap.data[idx+2], 10);\n        this.bitmap.data[idx] = grey;\n        this.bitmap.data[idx+1] = grey;\n        this.bitmap.data[idx+2] = grey;\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n// Alias of greyscale for our American friends\nJimp.prototype.grayscale = Jimp.prototype.greyscale;\n\n/**\n * Applies a sepia tone to the image\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.sepia = function (cb) {\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var red = this.bitmap.data[idx];\n        var green = this.bitmap.data[idx+1];\n        var blue = this.bitmap.data[idx+2];\n\n        red = (red * 0.393) + (green * 0.769) + (blue * 0.189);\n        green = (red * 0.349) + (green * 0.686) + (blue * 0.168);\n        blue = (red * 0.272) + (green * 0.534) + (blue * 0.131);\n        this.bitmap.data[idx] = (red < 255) ? red : 255;\n        this.bitmap.data[idx+1] = (green < 255) ? green : 255;\n        this.bitmap.data[idx+2] = (blue < 255) ? blue : 255;\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Multiplies the opacity of each pixel by a factor between 0 and 1\n * @param f A number, the factor by wich to multiply the opacity of each pixel\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.opacity = function (f, cb) {\n    if (\"number\" != typeof f)\n        return throwError.call(this, \"f must be a number\", cb);\n    if (f < 0 || f > 1)\n        return throwError.call(this, \"f must be a number from 0 to 1\", cb);\n\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var v = this.bitmap.data[idx+3] * f;\n        this.bitmap.data[idx+3] = v;\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Fades each pixel by a factor between 0 and 1\n * @param f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.fade = function (f, cb) {\n    if (\"number\" != typeof f)\n        return throwError.call(this, \"f must be a number\", cb);\n    if (f < 0 || f > 1)\n        return throwError.call(this, \"f must be a number from 0 to 1\", cb);\n\n    // this method is an alternative to opacity (which may be deprecated)\n    this.opacity(1 - f);\n    \n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Set the alpha channel on every pixel to fully opaque\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.opaque = function (cb) {\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data[idx+3] = 255;\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Resizes the image to a set width and height using a 2-pass bilinear algorithm\n * @param w the width to resize the image to (or Jimp.AUTO)\n * @param h the height to resize the image to (or Jimp.AUTO)\n * @param (optional) mode a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.resize = function (w, h, mode, cb) {\n    if (\"number\" != typeof w || \"number\" != typeof h)\n        return throwError.call(this, \"w and h must be numbers\", cb);\n    \n    if (\"function\" == typeof mode && \"undefined\" == typeof cb) {\n        cb = mode;\n        mode = null;\n    }\n    \n    if (w == Jimp.AUTO && h == Jimp.AUTO)\n        return throwError.call(this, \"w and h cannot both the set to auto\", cb);\n\n    if (w == Jimp.AUTO) w = this.bitmap.width * (h / this.bitmap.height);\n    if (h == Jimp.AUTO) h = this.bitmap.height * (w / this.bitmap.width);\n    \n    // round inputs\n    w = Math.round(w);\n    h = Math.round(h);\n\n    if (\"function\" == typeof Resize2[mode]) {\n        var dst = {\n            data: new Buffer(w * h * 4),\n            width: w,\n            height: h\n        };\n        Resize2[mode](this.bitmap, dst);\n        this.bitmap = dst;\n    } else {\n        var that = this;\n        var resize = new Resize(this.bitmap.width, this.bitmap.height, w, h, true, true, function (buffer) {\n            that.bitmap.data = new Buffer(buffer);\n            that.bitmap.width = w;\n            that.bitmap.height = h;\n        });\n        resize.resize(this.bitmap.data);\n    }\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Scale the image so the given width and height keeping the aspect ratio. Some parts of the image may be clipped.\n * @param w the width to resize the image to\n * @param h the height to resize the image to\n * @param (optional) alignBits A bitmask for horizontal and vertical alignment\n * @param (optional) mode a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.cover = function (w, h, alignBits, mode, cb) {\n    if (\"number\" != typeof w || \"number\" != typeof h)\n        return throwError.call(this, \"w and h must be numbers\", cb);\n\n    if (alignBits && \"function\" == typeof alignBits && \"undefined\" == typeof cb) {\n        cb = alignBits;\n        alignBits = null;\n        mode = null;\n    } else if (\"function\" == typeof mode && \"undefined\" == typeof cb) {\n        cb = mode;\n        mode = null;\n    }\n\n    alignBits = alignBits || (Jimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE);\n    var hbits = ((alignBits) & ((1<<(3))-1));\n    var vbits = alignBits >> 3;\n\n    // check if more flags than one is in the bit sets\n    if(!(((hbits != 0) && !(hbits & (hbits - 1))) || ((vbits != 0) && !(vbits & (vbits - 1)))))\n        return throwError.call(this, \"only use one flag per alignment direction\", cb);\n\n    var align_h = (hbits >> 1); // 0, 1, 2\n    var align_v = (vbits >> 1); // 0, 1, 2\n    \n    var f = (w/h > this.bitmap.width/this.bitmap.height) ?\n        w/this.bitmap.width : h/this.bitmap.height;\n    this.scale(f, mode);\n    this.crop(((this.bitmap.width - w) / 2) * align_h, ((this.bitmap.height - h) / 2) * align_v, w, h);\n    \n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.\n * @param w the width to resize the image to\n * @param h the height to resize the image to\n * @param (optional) alignBits A bitmask for horizontal and vertical alignment\n * @param (optional) mode a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.contain = function (w, h, alignBits, mode, cb) {\n    if (\"number\" != typeof w || \"number\" != typeof h)\n        return throwError.call(this, \"w and h must be numbers\", cb);\n\n    //permit any sort of optional parameters combination\n    switch (typeof alignBits) {\n        case 'string':\n            if (\"function\" == typeof mode && \"undefined\" == typeof cb) cb = mode;\n            mode = alignBits;\n            alignBits = null;\n        case 'function':\n            if (\"undefined\" == typeof cb) cb = alignBits;\n            mode = null;\n            alignBits = null;\n        default:\n            if (\"function\" == typeof mode && \"undefined\" == typeof cb) {\n                cb = mode;\n                mode = null;\n            }\n    }\n    \n    alignBits = alignBits || (Jimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE);\n    var hbits = ((alignBits) & ((1<<(3))-1));\n    var vbits = alignBits >> 3;\n\n    // check if more flags than one is in the bit sets\n    if(!(((hbits != 0) && !(hbits & (hbits - 1))) || ((vbits != 0) && !(vbits & (vbits - 1)))))\n        return throwError.call(this, \"only use one flag per alignment direction\", cb);\n\n    var align_h = (hbits >> 1); // 0, 1, 2\n    var align_v = (vbits >> 1); // 0, 1, 2\n\n    var f = (w/h > this.bitmap.width/this.bitmap.height) ?\n        h/this.bitmap.height : w/this.bitmap.width;\n    var c = this.clone().scale(f, mode);\n    \n    this.resize(w, h, mode);\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    this.blit(c, ((this.bitmap.width - c.bitmap.width) / 2) * align_h, ((this.bitmap.height - c.bitmap.height) / 2) * align_v);\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Uniformly scales the image by a factor.\n * @param f the factor to scale the image by\n * @param (optional) mode a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.scale = function (f, mode, cb) {\n    if (\"number\" != typeof f)\n        return throwError.call(this, \"f must be a number\", cb);\n    if (f < 0)\n        return throwError.call(this, \"f must be a positive number\", cb);\n\n    if (\"function\" == typeof mode && \"undefined\" == typeof cb) {\n        cb = mode;\n        mode = null;\n    }\n    \n    var w = this.bitmap.width * f;\n    var h = this.bitmap.height * f;\n    this.resize(w, h, mode);\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Scale the image to the largest size that fits inside the rectangle that has the given width and height.\n * @param w the width to resize the image to\n * @param h the height to resize the image to\n * @param (optional) mode a scaling method (e.g. Jimp.RESIZE_BEZIER)\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.scaleToFit = function (w, h, mode, cb) {\n    if (\"number\" != typeof w || \"number\" != typeof h)\n        return throwError.call(this, \"w and h must be numbers\", cb);\n\n    if (\"function\" == typeof mode && \"undefined\" == typeof cb) {\n        cb = mode;\n        mode = null;\n    }\n    \n    var f = (w/h > this.bitmap.width/this.bitmap.height) ?\n        h/this.bitmap.height : w/this.bitmap.width;\n    this.scale(f, mode);\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Rotates an image clockwise by a number of degrees rounded to the nearest 90 degrees. NB: 'this' must be a Jimp object.\n * @param deg the number of degress to rotate the image by\n * @returns nothing\n */\nfunction simpleRotate(deg) {\n    var i = Math.round(deg / 90) % 4;\n    while (i < 0) i += 4;\n\n    while (i > 0) {\n        // https://github.com/ekulabuhov/jimp/commit/9a0c7cff88292d88c32a424b11256c76f1e20e46\n        var dstBuffer = new Buffer(this.bitmap.data.length);\n        var dstOffset = 0;\n        for (var x = 0; x < this.bitmap.width; x++) {\n            for (var y = this.bitmap.height - 1; y >= 0; y--) {\n                var srcOffset = (this.bitmap.width * y + x) << 2;\n                var data = this.bitmap.data.readUInt32BE(srcOffset, true);\n                dstBuffer.writeUInt32BE(data, dstOffset, true);\n                dstOffset += 4;\n            }\n        }\n\n        this.bitmap.data = new Buffer(dstBuffer);\n        \n        var tmp = this.bitmap.width;\n        this.bitmap.width = this.bitmap.height;\n        this.bitmap.height = tmp;\n\n        i--;\n    }\n}\n\n/**\n * Rotates an image clockwise by an arbitary number of degrees. NB: 'this' must be a Jimp object.\n * @param deg the number of degress to rotate the image by\n * @param (optional) mode resize mode or a boolean, if false then the width and height of the image will not be changed\n * @returns nothing\n */\nfunction advancedRotate(deg, mode) {\n    var rad = (deg % 360) * Math.PI / 180;\n    var cosine = Math.cos(rad);\n    var sine = Math.sin(rad);\n    \n    var w, h; // the final width and height if resize == true\n\n    if (mode == true || \"string\" == typeof mode) {\n        // resize the image to it maximum dimention and blit the existing image onto the centre so that when it is rotated the image is kept in bounds\n\n        // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n        w = Math.round(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine));\n        h = Math.round(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine));\n\n        var c = this.clone();\n        this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n            this.bitmap.data.writeUInt32BE(this._background, idx);\n        });\n        \n        var max= Math.max(w,h,this.bitmap.width,this.bitmap.height)\n        this.resize(max, max, mode);\n        \n        this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);\n    }\n\n    var dstBuffer = new Buffer(this.bitmap.data.length);\n    \n    function createTranslationFunction(deltaX, deltaY) {\n        return function(x, y) {\n            return {\n                x : (x + deltaX),\n                y : (y + deltaY)\n            };\n        }\n    }\n\n    var translate2Cartesian = createTranslationFunction(-(this.bitmap.width / 2), -(this.bitmap.height / 2));\n    var translate2Screen = createTranslationFunction(this.bitmap.width / 2, this.bitmap.height / 2);\n    \n    for (var y = 0; y < this.bitmap.height; y++) {\n        for (var x = 0; x < this.bitmap.width; x++) {\n            var cartesian = translate2Cartesian(x, this.bitmap.height - y);\n            var source = translate2Screen(\n                cosine * cartesian.x - sine * cartesian.y,\n                cosine * cartesian.y + sine * cartesian.x\n            );\n            if (source.x >= 0 && source.x < this.bitmap.width\n                && source.y >= 0 && source.y < this.bitmap.height) {\n                var srcIdx = (this.bitmap.width * (this.bitmap.height - source.y | 0) + source.x | 0) << 2;\n                var pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx, true);\n                var dstIdx = (this.bitmap.width * y + x) << 2;\n                dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n            } else {\n                // reset off-image pixels\n                var dstIdx = (this.bitmap.width * y + x) << 2;\n                dstBuffer.writeUInt32BE(this._background, dstIdx);\n            }\n        }\n    }\n    this.bitmap.data = dstBuffer;\n    \n    if (mode == true || \"string\" == typeof mode) {\n        // now crop the image to the final size\n        var x = (this.bitmap.width / 2) - (w/2);\n        var y = (this.bitmap.height / 2) - (h/2);\n        this.crop(x, y, w, h);\n    }\n};\n\n\n/**\n * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n * @param deg the number of degress to rotate the image by\n * @param (optional) mode resize mode or a boolean, if false then the width and height of the image will not be changed\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.rotate = function (deg, mode, cb) {\n    // enable overloading\n    if (\"undefined\" == typeof mode || mode === null) {\n        // e.g. image.resize(120);\n        // e.g. image.resize(120, null, cb);\n        // e.g. image.resize(120, undefined, cb);\n        mode = true;\n    }\n    if (\"function\" == typeof mode && \"undefined\" == typeof cb) {\n        // e.g. image.resize(120, cb);\n        cb = mode;\n        mode = true;\n    }\n    \n    if (\"number\" != typeof deg)\n        return throwError.call(this, \"deg must be a number\", cb);\n    \n    if (\"boolean\" != typeof mode && \"string\" != typeof mode)\n        return throwError.call(this, \"mode must be a boolean or a string\", cb);\n\n    if (deg % 90 == 0 && mode !== false) simpleRotate.call(this, deg, cb);\n    else advancedRotate.call(this, deg, mode, cb);\n    \n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n};\n\n/**\n * Converts the image to a buffer\n * @param mime the mime type of the image buffer to be created\n * @param cb a Node-style function to call with the buffer as the second argument\n * @returns this for chaining of methods\n */\nJimp.prototype.getBuffer = function (mime, cb) {\n    if (mime == Jimp.AUTO) { // allow auto MIME detection\n        mime = this._originalMime || Jimp.MIME_PNG;\n    }\n    \n    if (\"string\" != typeof mime)\n        return throwError.call(this, \"mime must be a string\", cb);\n    if (\"function\" != typeof cb)\n        return throwError.call(this, \"cb must be a function\", cb);\n\n    switch (mime.toLowerCase()) {\n        case Jimp.MIME_PNG:\n            var that = this;\n            var png = new PNG({\n              width: this.bitmap.width,\n              height:this.bitmap.height,\n              bitDepth: 8,\n              deflateLevel: this._deflateLevel,\n              deflateStrategy: this._deflateStrategy,\n              filterType: this._filterType,\n              colorType: (this._rgba) ? 6 : 2,\n              inputHasAlpha: true\n            });\n            \n            if (this._rgba) png.data = new Buffer(this.bitmap.data);\n            else png.data = compositeBitmapOverBackground(this).data; // when PNG doesn't support alpha\n            \n            StreamToBuffer(png.pack(), function (err, buffer) {\n                return cb.call(that, null, buffer);\n            });\n            break;\n\n        case Jimp.MIME_JPEG:\n            // composite onto a new image so that the background shows through alpha channels\n            var jpeg = JPEG.encode(compositeBitmapOverBackground(this), this._quality);\n            return cb.call(this, null, jpeg.data);\n\n        case Jimp.MIME_BMP:\n            // composite onto a new image so that the background shows through alpha channels\n            var bmp = BMP.encode(compositeBitmapOverBackground(this));\n            return cb.call(this, null, bmp.data);\n\n        default:\n            return cb.call(this, \"Unsupported MIME type: \" + mime);\n    }\n\n    return this;\n};\n\nfunction compositeBitmapOverBackground(image){\n    return (new Jimp(image.bitmap.width, image.bitmap.height, image._background)).composite(image, 0, 0).bitmap;\n}\n\n/**\n * Converts the image to a base 64 string\n * @param mime the mime type of the image data to be created\n * @param cb a Node-style function to call with the buffer as the second argument\n * @returns this for chaining of methods\n */\nJimp.prototype.getBase64 = function (mime, cb) {\n    if (mime == Jimp.AUTO) { // allow auto MIME detection\n        mime = this._originalMime || Jimp.MIME_PNG;\n    }\n    \n    if (\"string\" != typeof mime)\n        return throwError.call(this, \"mime must be a string\", cb);\n    if (\"function\" != typeof cb)\n        return throwError.call(this, \"cb must be a function\", cb);\n\n    this.getBuffer(mime, function(err, data) {\n        var src = \"data:\" + mime + \";base64,\"  + data.toString(\"base64\");\n        return cb.call(this, null, src);\n    });\n    \n    return this;\n};\n\n/**\n * Apply a ordered dithering effect\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.dither565 = function (cb) {\n    var rgb565_matrix = [\n      1, 9, 3, 11,\n      13, 5, 15, 7,\n      4, 12, 2, 10,\n      16, 8, 14, 6\n    ];\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var tresshold_id = ((y & 3) << 2) + (x % 4);\n        var dither = rgb565_matrix[tresshold_id];\n        this.bitmap.data[idx  ] = Math.min(this.bitmap.data[idx]   + dither, 0xff);\n        this.bitmap.data[idx+1] = Math.min(this.bitmap.data[idx+1] + dither, 0xff);\n        this.bitmap.data[idx+2] = Math.min(this.bitmap.data[idx+2] + dither, 0xff);\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n}\n\n\n// alternative reference\nJimp.prototype.dither16 = Jimp.prototype.dither565;\n\n/**\n * Apply multiple color modification rules\n * @param actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }\n * @param (optional) cb a callback for when complete\n * @returns this for chaining of methods\n */\nJimp.prototype.color = Jimp.prototype.colour = function (actions, cb) {\n    if (!actions || !Array.isArray(actions))\n        return throwError.call(this, \"actions must be an array\", cb);\n\n    var originalScope = this;\n    this.scan(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var clr = TinyColor({r: this.bitmap.data[idx], g: this.bitmap.data[idx + 1], b: this.bitmap.data[idx + 2]});\n\n        var colorModifier = function (i, amount) {\n          c = clr.toRgb();\n          c[i] = Math.max(0, Math.min(c[i] + amount, 255));\n          return TinyColor(c);\n        }\n\n        actions.forEach(function (action) {\n            if (action.apply === \"mix\") {\n                clr = TinyColor.mix(clr, action.params[0], action.params[1]);\n            } else if (action.apply === \"tint\") {\n              clr = TinyColor.mix(clr, \"white\", action.params[0]);\n            } else if (action.apply === \"shade\") {\n              clr = TinyColor.mix(clr, \"black\", action.params[0]);\n            } else if (action.apply === \"xor\") {\n              var clr2 = TinyColor(action.params[0]).toRgb();\n              clr = clr.toRgb();\n              clr = TinyColor({ r: clr.r ^ clr2.r, g: clr.g ^ clr2.g, b: clr.b ^ clr2.b});\n            } else if (action.apply === \"red\") {\n              clr = colorModifier(\"r\", action.params[0]);\n            } else if (action.apply === \"green\") {\n              clr = colorModifier(\"g\", action.params[0]);\n            } else if (action.apply === \"blue\") {\n              clr = colorModifier(\"b\", action.params[0]);\n            } else {\n                if (action.apply === \"hue\") {\n                    action.apply = \"spin\";\n                }\n\n                var fn = clr[action.apply];\n                if (!fn) {\n                    return throwError.call(originalScope, \"action \" + action.apply + \" not supported\", cb);\n                }\n                clr = fn.apply(clr, action.params);\n            }\n        });\n\n        clr = clr.toRgb();\n        this.bitmap.data[idx  ] = clr.r;\n        this.bitmap.data[idx+1] = clr.g;\n        this.bitmap.data[idx+2] = clr.b;\n    });\n\n    if (isNodePattern(cb)) return cb.call(this, null, this);\n    else return this;\n}\n\n/**\n * Loads a bitmap font from a file\n * @param file the file path of a .fnt file\n * @param (optional) cb a function to call when the font is loaded\n * @returns a promise\n */\nJimp.loadFont = function (file, cb) {\n    if (\"string\" != typeof file)\n        return throwError.call(this, \"file must be a string\", cb);\n\n    var that = this;\n\n    return new Promise(function (resolve, reject) { \n        cb = cb || function(err, font) {\n            if (err) reject(err);\n            else resolve(font);\n        }\n\n        BMFont(file, function(err, font) {\n            var chars = {}, kernings = {};\n\n            if (err) return throwError.call(that, err, cb);\n\n            for (var i = 0; i < font.chars.length; i++) {\n                chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];\n            }\n\n            for (var i = 0; i < font.kernings.length; i++) {\n                var firstString = String.fromCharCode(font.kernings[i].first);\n                kernings[firstString] = kernings[firstString] || {};\n                kernings[firstString][String.fromCharCode(font.kernings[i].second)] = font.kernings[i].amount;\n            }\n\n            loadPages(Path.dirname(file), font.pages).then(function (pages) {\n                cb(null, {\n                    chars: chars,\n                    kernings: kernings,\n                    pages: pages,\n                    common: font.common,\n                    info: font.info\n                });\n            });\n        });\n    });\n};\n\nfunction loadPages(dir, pages) {\n  var newPages = pages.map(function (page) {\n    return Jimp.read(dir + '/' + page);\n  });\n\n  return Promise.all(newPages);\n}\n\n/**\n * Draws a text on a image on a given boundary\n * @param font a bitmap font loaded from `Jimp.loadFont` command\n * @param x the x position to start drawing the text\n * @param y the y position to start drawing the text\n * @param text the text to draw\n * @param maxWidth (optional) the boundary width to draw in\n * @param (optional) cb a function to call when the text is written\n * @returns this for chaining of methods\n */\nJimp.prototype.print = function (font, x, y, text, maxWidth, cb) {\n    if (\"function\" == typeof maxWidth && \"undefined\" == typeof cb) {\n        cb = maxWidth;\n        maxWidth = Infinity;\n    }\n    if (\"undefined\" == typeof maxWidth) {\n        maxWidth = Infinity;\n    }\n    \n    if (\"object\" != typeof font)\n        return throwError.call(this, \"font must be a Jimp loadFont\", cb);\n    if (\"number\" != typeof x || \"number\" != typeof y || \"number\" != typeof maxWidth)\n        return throwError.call(this, \"x, y and maxWidth must be numbers\", cb);\n    if (\"string\" != typeof text)\n        return throwError.call(this, \"text must be a string\", cb);\n    if (\"number\" != typeof maxWidth)\n        return throwError.call(this, \"maxWidth must be a number\", cb);\n\n    var that = this;\n    \n    var words = text.split(' ');\n    var line = '';\n\n    for (var n = 0; n < words.length; n++) {\n        var testLine = line + words[n] + ' ';\n        var testWidth = measureText(font, testLine);\n        if (testWidth > maxWidth && n > 0) {\n            that = that.print(font, x, y, line);\n            line = words[n] + ' ';\n            y += font.common.lineHeight;\n        } else {\n            line = testLine;\n        }\n    }\n    printText.call(this, font, x, y, line);\n\n    if (isNodePattern(cb)) return cb.call(this, null, that);\n    else return that;\n};\n\nfunction printText(font, x, y, text) {\n    for (var i = 0; i < text.length; i++) {\n      if (font.chars[text[i]]) {\n        drawCharacter(this, font, x, y, font.chars[text[i]]);\n        x += (font.kernings[text[i]] && font.kernings[text[i]][text[i+1]] ? font.kernings[text[i]][text[i+1]] : 0) + (font.chars[text[i]].xadvance || 0);\n      }\n    }\n};\n\nfunction drawCharacter(image, font, x, y, char) {\n    if (char.width > 0 && char.height > 0) {\n        var imageChar = font.pages[char.page].clone().crop(char.x, char.y, char.width, char.height);\n        return image.composite(imageChar, x + char.xoffset, y + char.yoffset);\n    }\n    return image;\n};\n\nfunction measureText(font, text) {\n  var x = 0;\n  for (var i = 0; i < text.length; i++) {\n      if (font.chars[text[i]]) {\n          x += font.chars[text[i]].xoffset\n            + (font.kernings[text[i]] && font.kernings[text[i]][text[i+1]] ? font.kernings[text[i]][text[i+1]] : 0)\n            + (font.chars[text[i]].xadvance || 0);\n      }\n  }\n  return x;\n};\n\n/**\n * Writes the image to a file\n * @param path a path to the destination file (either PNG or JPEG)\n * @param (optional) cb a function to call when the image is saved to disk\n * @returns this for chaining of methods\n */\nJimp.prototype.write = function (path, cb) {\n    if (\"string\" != typeof path)\n        return throwError.call(this, \"path must be a string\", cb);\n    if (\"undefined\" == typeof cb) cb = function () {};\n    if (\"function\" != typeof cb)\n        return throwError.call(this, \"cb must be a function\", cb);\n\n    var that = this;\n    var mime = MIME.lookup(path);\n\n    this.getBuffer(mime, function(err, buffer) {\n        if (err) return throwError.call(that, err, cb);\n        var stream = FS.createWriteStream(path);\n        stream.on(\"open\", function(fh) {\n            stream.write(buffer);\n            stream.end();\n        }).on(\"error\", function(err) {\n            return throwError.call(that, err, cb);\n        });\n        stream.on(\"finish\", function(fh) {\n            return cb.call(that, null, that);\n        });\n    });\n\n    return this;\n};\n\nif (process.env.ENVIRONMENT === \"BROWSER\") {\n    // For use in a web browser or web worker\n    var gl;\n    if (typeof window == \"object\") gl = window;\n    if (typeof self == \"object\") gl = self;\n\n    gl.Jimp = Jimp;\n    gl.Buffer = Buffer;\n} else {\n    module.exports = Jimp;\n}\n","/home/travis/build/npmtest/node-npmtest-jimp/node_modules/jimp/resize.js":"// JavaScript Image Resizer (c) 2012 - Grant Galitz\n// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4\n\nfunction Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {\n    this.widthOriginal = Math.abs(parseInt(widthOriginal) || 0);\n    this.heightOriginal = Math.abs(parseInt(heightOriginal) || 0);\n    this.targetWidth = Math.abs(parseInt(targetWidth) || 0);\n    this.targetHeight = Math.abs(parseInt(targetHeight) || 0);\n    this.colorChannels = (!!blendAlpha) ? 4 : 3;\n    this.interpolationPass = !!interpolationPass;\n    this.resizeCallback = (typeof resizeCallback == \"function\") ? resizeCallback : function (returnedArray) {};\n    this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;\n    this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;\n    this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;\n    this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;\n    this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;\n    this.initialize();\n}\n\nResize.prototype.initialize = function () {\n    //Perform some checks:\n    if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {\n        this.configurePasses();\n    } else {\n        throw (new Error(\"Invalid settings specified for the resizer.\"));\n    }\n}\n\nResize.prototype.configurePasses = function () {\n    if (this.widthOriginal == this.targetWidth) {\n        //Bypass the width resizer pass:\n        this.resizeWidth = this.bypassResizer;\n    } else {\n        //Setup the width resizer pass:\n        this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;\n        if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {\n            this.initializeFirstPassBuffers(true);\n            this.resizeWidth = (this.colorChannels == 4) ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;\n        } else {\n            this.initializeFirstPassBuffers(false);\n            this.resizeWidth = (this.colorChannels == 4) ? this.resizeWidthRGBA : this.resizeWidthRGB;\n        }\n    }\n    if (this.heightOriginal == this.targetHeight) {\n        //Bypass the height resizer pass:\n        this.resizeHeight = this.bypassResizer;\n    } else {\n        //Setup the height resizer pass:\n        this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;\n        if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {\n            this.initializeSecondPassBuffers(true);\n            this.resizeHeight = this.resizeHeightInterpolated;\n        } else {\n            this.initializeSecondPassBuffers(false);\n            this.resizeHeight = (this.colorChannels == 4) ? this.resizeHeightRGBA : this.resizeHeightRGB;\n        }\n    }\n}\n\nResize.prototype.resizeWidthRGB = function (buffer) {\n    var ratioWeight = this.ratioWeightWidthPass;\n    var ratioWeightDivisor = 1 / ratioWeight;\n    var weight = 0;\n    var amountToNext = 0;\n    var actualPosition = 0;\n    var currentPosition = 0;\n    var line = 0;\n    var pixelOffset = 0;\n    var outputOffset = 0;\n    var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - 2;\n    var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - 2;\n    var output = this.outputWidthWorkBench;\n    var outputBuffer = this.widthBuffer;\n    do {\n        for (line = 0; line < this.originalHeightMultipliedByChannels;) {\n            output[line++] = 0;\n            output[line++] = 0;\n            output[line++] = 0;\n        }\n        weight = ratioWeight;\n        do {\n            amountToNext = 1 + actualPosition - currentPosition;\n            if (weight >= amountToNext) {\n                for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {\n                    output[line++] += buffer[pixelOffset++] * amountToNext;\n                    output[line++] += buffer[pixelOffset++] * amountToNext;\n                    output[line++] += buffer[pixelOffset] * amountToNext;\n                }\n                currentPosition = actualPosition = actualPosition + 3;\n                weight -= amountToNext;\n            } else {\n                for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {\n                    output[line++] += buffer[pixelOffset++] * weight;\n                    output[line++] += buffer[pixelOffset++] * weight;\n                    output[line++] += buffer[pixelOffset] * weight;\n                }\n                currentPosition += weight;\n                break;\n            }\n        } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);\n        for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {\n            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;\n            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;\n            outputBuffer[pixelOffset] = output[line++] * ratioWeightDivisor;\n        }\n        outputOffset += 3;\n    } while (outputOffset < this.targetWidthMultipliedByChannels);\n    return outputBuffer;\n}\n\nResize.prototype.resizeWidthInterpolatedRGB = function (buffer) {\n    var ratioWeight = this.ratioWeightWidthPass;\n    var weight = 0;\n    var finalOffset = 0;\n    var pixelOffset = 0;\n    var firstWeight = 0;\n    var secondWeight = 0;\n    var outputBuffer = this.widthBuffer;\n    //Handle for only one interpolation input being valid for start calculation:\n    for (var targetPosition = 0; weight < 1 / 3; targetPosition += 3, weight += ratioWeight) {\n        for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n            outputBuffer[finalOffset] = buffer[pixelOffset];\n            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n        }\n    }\n    //Adjust for overshoot of the last pass's counter:\n    weight -= 1 / 3;\n    for (var interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += 3, weight += ratioWeight) {\n        //Calculate weightings:\n        secondWeight = weight % 1;\n        firstWeight = 1 - secondWeight;\n        //Interpolate:\n        for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * 3; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n            outputBuffer[finalOffset] = (buffer[pixelOffset] * firstWeight) + (buffer[pixelOffset + 3] * secondWeight);\n            outputBuffer[finalOffset + 1] = (buffer[pixelOffset + 1] * firstWeight) + (buffer[pixelOffset + 4] * secondWeight);\n            outputBuffer[finalOffset + 2] = (buffer[pixelOffset + 2] * firstWeight) + (buffer[pixelOffset + 5] * secondWeight);\n        }\n    }\n    //Handle for only one interpolation input being valid for end calculation:\n    for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - 3; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += 3) {\n        for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n            outputBuffer[finalOffset] = buffer[pixelOffset];\n            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n        }\n    }\n    return outputBuffer;\n}\n\nResize.prototype.resizeWidthRGBA = function (buffer) {\n    var ratioWeight = this.ratioWeightWidthPass;\n    var ratioWeightDivisor = 1 / ratioWeight;\n    var weight = 0;\n    var amountToNext = 0;\n    var actualPosition = 0;\n    var currentPosition = 0;\n    var line = 0;\n    var pixelOffset = 0;\n    var outputOffset = 0;\n    var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - 3;\n    var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - 3;\n    var output = this.outputWidthWorkBench;\n    var outputBuffer = this.widthBuffer;\n    do {\n        for (line = 0; line < this.originalHeightMultipliedByChannels;) {\n            output[line++] = 0;\n            output[line++] = 0;\n            output[line++] = 0;\n            output[line++] = 0;\n        }\n        weight = ratioWeight;\n        do {\n            amountToNext = 1 + actualPosition - currentPosition;\n            if (weight >= amountToNext) {\n                for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {\n                    output[line++] += buffer[pixelOffset++] * amountToNext;\n                    output[line++] += buffer[pixelOffset++] * amountToNext;\n                    output[line++] += buffer[pixelOffset++] * amountToNext;\n                    output[line++] += buffer[pixelOffset] * amountToNext;\n                }\n                currentPosition = actualPosition = actualPosition + 4;\n                weight -= amountToNext;\n            } else {\n                for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {\n                    output[line++] += buffer[pixelOffset++] * weight;\n                    output[line++] += buffer[pixelOffset++] * weight;\n                    output[line++] += buffer[pixelOffset++] * weight;\n                    output[line++] += buffer[pixelOffset] * weight;\n                }\n                currentPosition += weight;\n                break;\n            }\n        } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);\n        for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {\n            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;\n            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;\n            outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;\n            outputBuffer[pixelOffset] = output[line++] * ratioWeightDivisor;\n        }\n        outputOffset += 4;\n    } while (outputOffset < this.targetWidthMultipliedByChannels);\n    return outputBuffer;\n}\n\nResize.prototype.resizeWidthInterpolatedRGBA = function (buffer) {\n    var ratioWeight = this.ratioWeightWidthPass;\n    var weight = 0;\n    var finalOffset = 0;\n    var pixelOffset = 0;\n    var firstWeight = 0;\n    var secondWeight = 0;\n    var outputBuffer = this.widthBuffer;\n    //Handle for only one interpolation input being valid for start calculation:\n    for (var targetPosition = 0; weight < 1 / 3; targetPosition += 4, weight += ratioWeight) {\n        for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n            outputBuffer[finalOffset] = buffer[pixelOffset];\n            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n        }\n    }\n    //Adjust for overshoot of the last pass's counter:\n    weight -= 1 / 3;\n    for (var interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += 4, weight += ratioWeight) {\n        //Calculate weightings:\n        secondWeight = weight % 1;\n        firstWeight = 1 - secondWeight;\n        //Interpolate:\n        for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * 4; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n            outputBuffer[finalOffset] = (buffer[pixelOffset] * firstWeight) + (buffer[pixelOffset + 4] * secondWeight);\n            outputBuffer[finalOffset + 1] = (buffer[pixelOffset + 1] * firstWeight) + (buffer[pixelOffset + 5] * secondWeight);\n            outputBuffer[finalOffset + 2] = (buffer[pixelOffset + 2] * firstWeight) + (buffer[pixelOffset + 6] * secondWeight);\n            outputBuffer[finalOffset + 3] = (buffer[pixelOffset + 3] * firstWeight) + (buffer[pixelOffset + 7] * secondWeight);\n        }\n    }\n    //Handle for only one interpolation input being valid for end calculation:\n    for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - 4; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += 4) {\n        for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {\n            outputBuffer[finalOffset] = buffer[pixelOffset];\n            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n        }\n    }\n    return outputBuffer;\n}\n\nResize.prototype.resizeHeightRGB = function (buffer) {\n    var ratioWeight = this.ratioWeightHeightPass;\n    var ratioWeightDivisor = 1 / ratioWeight;\n    var weight = 0;\n    var amountToNext = 0;\n    var actualPosition = 0;\n    var currentPosition = 0;\n    var pixelOffset = 0;\n    var outputOffset = 0;\n    var output = this.outputHeightWorkBench;\n    var outputBuffer = this.heightBuffer;\n    do {\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n            output[pixelOffset++] = 0;\n            output[pixelOffset++] = 0;\n            output[pixelOffset++] = 0;\n        }\n        weight = ratioWeight;\n        do {\n            amountToNext = 1 + actualPosition - currentPosition;\n            if (weight >= amountToNext) {\n                for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;\n                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;\n                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;\n                }\n                currentPosition = actualPosition;\n                weight -= amountToNext;\n            } else {\n                for (pixelOffset = 0, amountToNext = actualPosition; pixelOffset < this.targetWidthMultipliedByChannels;) {\n                    output[pixelOffset++] += buffer[amountToNext++] * weight;\n                    output[pixelOffset++] += buffer[amountToNext++] * weight;\n                    output[pixelOffset++] += buffer[amountToNext++] * weight;\n                }\n                currentPosition += weight;\n                break;\n            }\n        } while (weight > 0 && actualPosition < this.widthPassResultSize);\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n        }\n    } while (outputOffset < this.finalResultSize);\n    return outputBuffer;\n}\n\nResize.prototype.resizeHeightInterpolated = function (buffer) {\n    var ratioWeight = this.ratioWeightHeightPass;\n    var weight = 0;\n    var finalOffset = 0;\n    var pixelOffset = 0;\n    var pixelOffsetAccumulated = 0;\n    var pixelOffsetAccumulated2 = 0;\n    var firstWeight = 0;\n    var secondWeight = 0;\n    var outputBuffer = this.heightBuffer;\n    //Handle for only one interpolation input being valid for start calculation:\n    for (; weight < 1 / 3; weight += ratioWeight) {\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);\n        }\n    }\n    //Adjust for overshoot of the last pass's counter:\n    weight -= 1 / 3;\n    for (var interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {\n        //Calculate weightings:\n        secondWeight = weight % 1;\n        firstWeight = 1 - secondWeight;\n        //Interpolate:\n        pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;\n        pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n            outputBuffer[finalOffset++] = Math.round((buffer[pixelOffsetAccumulated++] * firstWeight) + (buffer[pixelOffsetAccumulated2++] * secondWeight));\n        }\n    }\n    //Handle for only one interpolation input being valid for end calculation:\n    while (finalOffset < this.finalResultSize) {\n        for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);\n        }\n    }\n    return outputBuffer;\n}\n\nResize.prototype.resizeHeightRGBA = function (buffer) {\n    var ratioWeight = this.ratioWeightHeightPass;\n    var ratioWeightDivisor = 1 / ratioWeight;\n    var weight = 0;\n    var amountToNext = 0;\n    var actualPosition = 0;\n    var currentPosition = 0;\n    var pixelOffset = 0;\n    var outputOffset = 0;\n    var output = this.outputHeightWorkBench;\n    var outputBuffer = this.heightBuffer;\n    do {\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n            output[pixelOffset++] = 0;\n            output[pixelOffset++] = 0;\n            output[pixelOffset++] = 0;\n            output[pixelOffset++] = 0;\n        }\n        weight = ratioWeight;\n        do {\n            amountToNext = 1 + actualPosition - currentPosition;\n            if (weight >= amountToNext) {\n                for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;\n                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;\n                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;\n                    output[pixelOffset++] += buffer[actualPosition++] * amountToNext;\n                }\n                currentPosition = actualPosition;\n                weight -= amountToNext;\n            } else {\n                for (pixelOffset = 0, amountToNext = actualPosition; pixelOffset < this.targetWidthMultipliedByChannels;) {\n                    output[pixelOffset++] += buffer[amountToNext++] * weight;\n                    output[pixelOffset++] += buffer[amountToNext++] * weight;\n                    output[pixelOffset++] += buffer[amountToNext++] * weight;\n                    output[pixelOffset++] += buffer[amountToNext++] * weight;\n                }\n                currentPosition += weight;\n                break;\n            }\n        } while (weight > 0 && actualPosition < this.widthPassResultSize);\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n        }\n    } while (outputOffset < this.finalResultSize);\n    return outputBuffer;\n}\n\nResize.prototype.resize = function (buffer) {\n    this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));\n}\n\nResize.prototype.bypassResizer = function (buffer) {\n    //Just return the buffer passsed:\n    return buffer;\n}\n\nResize.prototype.initializeFirstPassBuffers = function (BILINEARAlgo) {\n    //Initialize the internal width pass buffers:\n    this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);\n    if (!BILINEARAlgo) {\n        this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);\n    }\n}\n\nResize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {\n    //Initialize the internal height pass buffers:\n    this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);\n    if (!BILINEARAlgo) {\n        this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);\n    }\n}\n\nResize.prototype.generateFloatBuffer = function (bufferLength) {\n    //Generate a float32 typed array buffer:\n    try {\n        return new Float32Array(bufferLength);\n    } catch (error) {\n        return [];\n    }\n}\n\nResize.prototype.generateUint8Buffer = function (bufferLength) {\n    //Generate a uint8 typed array buffer:\n    try {\n        return new Uint8Array(bufferLength);\n    } catch (error) {\n        return [];\n    }\n}\n\nmodule.exports = Resize;\n","/home/travis/build/npmtest/node-npmtest-jimp/node_modules/jimp/resize2.js":"/**\n * Copyright (c) 2015 Guyon Roche\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\n\nmodule.exports = {\n    nearestNeighbor: function(src, dst, options) {\n        \n        var wSrc = src.width;\n        var hSrc = src.height;\n        //console.log(\"wSrc=\"+wSrc + \", hSrc=\"+hSrc);\n        \n        var wDst = dst.width;\n        var hDst = dst.height;\n        //console.log(\"wDst=\"+wDst + \", hDst=\"+hDst);\n        \n        var bufSrc = src.data;\n        var bufDst = dst.data;\n\n        for (var i = 0; i < hDst; i++) {\n            for (var j = 0; j < wDst; j++) {\n                var posDst = (i * wDst + j) * 4;\n                \n                var iSrc = Math.round(i * hSrc / hDst);\n                var jSrc = Math.round(j * wSrc / wDst);\n                var posSrc = (iSrc * wSrc + jSrc) * 4;\n                \n                bufDst[posDst++] = bufSrc[posSrc++];\n                bufDst[posDst++] = bufSrc[posSrc++];\n                bufDst[posDst++] = bufSrc[posSrc++];\n                bufDst[posDst++] = bufSrc[posSrc++];\n            }\n        }\n    },\n    bilinearInterpolation: function(src, dst, options) {\n        \n        var wSrc = src.width;\n        var hSrc = src.height;\n        //console.log(\"wSrc=\"+wSrc + \", hSrc=\"+hSrc);\n        \n        var wDst = dst.width;\n        var hDst = dst.height;\n        //console.log(\"wDst=\"+wDst + \", hDst=\"+hDst);\n        \n        var bufSrc = src.data;\n        var bufDst = dst.data;\n        \n        var interpolate = function(k, kMin, vMin, kMax, vMax) {\n            // special case - k is integer\n            if (kMin === kMax) {\n                return vMin;\n            }\n            \n            return Math.round((k - kMin) * vMax + (kMax - k) * vMin);\n        };\n        var assign = function(pos, offset, x, xMin, xMax, y, yMin, yMax) {\n            var posMin = (yMin * wSrc + xMin) * 4 + offset;\n            var posMax = (yMin * wSrc + xMax) * 4 + offset;\n            var vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);\n            \n            // special case, y is integer\n            if (yMax === yMin) {\n                bufDst[pos+offset] = vMin;\n            } else {\n                posMin = (yMax * wSrc + xMin) * 4 + offset;\n                posMax = (yMax * wSrc + xMax) * 4 + offset;\n                var vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);\n                \n                bufDst[pos+offset] = interpolate(y, yMin, vMin, yMax, vMax);\n            }\n        }\n        \n        for (var i = 0; i < hDst; i++) {\n            for (var j = 0; j < wDst; j++) {\n                var posDst = (i * wDst + j) * 4;\n                \n                // x & y in src coordinates\n                var x = j * wSrc / wDst;\n                var xMin = Math.floor(x);\n                var xMax = Math.min(Math.ceil(x), wSrc-1);\n                \n                var y = i * hSrc / hDst;\n                var yMin = Math.floor(y);\n                var yMax = Math.min(Math.ceil(y), hSrc-1);\n                \n                assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);\n                assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);\n                assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);\n                assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);\n            }\n        }\n    },\n    \n    _interpolate2D: function(src, dst, options, interpolate) {\n        \n        var bufSrc = src.data;\n        var bufDst = dst.data;\n        \n        var wSrc = src.width;\n        var hSrc = src.height;\n        //console.log(\"wSrc=\"+wSrc + \", hSrc=\"+hSrc + \", srcLen=\"+bufSrc.length);\n        \n        var wDst = dst.width;\n        var hDst = dst.height;\n        //console.log(\"wDst=\"+wDst + \", hDst=\"+hDst + \", dstLen=\"+bufDst.length);\n        \n        // when dst smaller than src/2, interpolate first to a multiple between 0.5 and 1.0 src, then sum squares\n        var wM = Math.max(1, Math.floor(wSrc / wDst));\n        var wDst2 = wDst * wM;\n        var hM = Math.max(1, Math.floor(hSrc / hDst));\n        var hDst2 = hDst * hM;\n        //console.log(\"wM=\"+wM + \", wDst2=\"+wDst2 + \", hM=\"+hM + \", hDst2=\"+hDst2);\n        \n        // ===========================================================\n        // Pass 1 - interpolate rows\n        // buf1 has width of dst2 and height of src\n        var buf1 = new Buffer(wDst2 * hSrc * 4);\n        for (var i = 0; i < hSrc; i++) {\n            for (var j = 0; j < wDst2; j++) {\n                // i in src coords, j in dst coords\n                \n                // calculate x in src coords\n                // this interpolation requires 4 sample points and the two inner ones must be real\n                // the outer points can be fudged for the edges.\n                // therefore (wSrc-1)/wDst2\n                var x = j * (wSrc-1) / wDst2;\n                var xPos = Math.floor(x);\n                var t = x - xPos;\n                var srcPos = (i * wSrc + xPos) * 4;\n                \n                var buf1Pos = (i * wDst2 + j) * 4;\n                for (var k = 0; k < 4; k++) {\n                    var kPos = srcPos + k;\n                    var x0 = (xPos > 0) ? bufSrc[kPos - 4] : 2*bufSrc[kPos]-bufSrc[kPos+4];\n                    var x1 = bufSrc[kPos];\n                    var x2 = bufSrc[kPos + 4];\n                    var x3 = (xPos < wSrc - 2) ? bufSrc[kPos + 8] : 2*bufSrc[kPos + 4]-bufSrc[kPos];\n                    buf1[buf1Pos+k] = interpolate(x0,x1,x2,x3,t);\n                }\n            }\n        }\n        //this._writeFile(wDst2, hSrc, buf1, \"out/buf1.jpg\");\n        \n        // ===========================================================\n        // Pass 2 - interpolate columns\n        // buf2 has width and height of dst2\n        var buf2 = new Buffer(wDst2 * hDst2 * 4);\n        for (var i = 0; i < hDst2; i++) {\n            for (var j = 0; j < wDst2; j++) {\n                // i&j in dst2 coords\n                \n                // calculate y in buf1 coords\n                // this interpolation requires 4 sample points and the two inner ones must be real\n                // the outer points can be fudged for the edges.\n                // therefore (hSrc-1)/hDst2\n                var y = i * (hSrc-1) / hDst2;\n                var yPos = Math.floor(y);\n                var t = y - yPos;\n                var buf1Pos = (yPos * wDst2 + j) * 4;\n                var buf2Pos = (i * wDst2 + j) * 4;\n                for (var k = 0; k < 4; k++) {\n                    var kPos = buf1Pos + k;\n                    var y0 = (yPos > 0) ? buf1[kPos - wDst2*4] : 2*buf1[kPos]-buf1[kPos + wDst2*4];\n                    var y1 = buf1[kPos];\n                    var y2 = buf1[kPos + wDst2*4];\n                    var y3 = (yPos < hSrc-2) ? buf1[kPos + wDst2*8] : 2*buf1[kPos + wDst2*4]-buf1[kPos];\n                    \n                    buf2[buf2Pos + k] = interpolate(y0,y1,y2,y3,t);\n                }\n            }\n        }\n        //this._writeFile(wDst2, hDst2, buf2, \"out/buf2.jpg\");\n        \n        // ===========================================================\n        // Pass 3 - scale to dst\n        var m = wM * hM;\n        if (m > 1) {\n            for (var i = 0; i < hDst; i++) {\n                for (var j = 0; j < wDst; j++) {\n                    // i&j in dst bounded coords\n                    var r = 0;\n                    var g = 0;\n                    var b = 0;\n                    var a = 0;\n                    for (var y = 0; y < hM; y++) {\n                        var yPos = i * hM + y;\n                        for (var x = 0; x < wM; x++) {\n                            var xPos = j * wM + x;\n                            var xyPos = (yPos * wDst2 + xPos) * 4;\n                            r += buf2[xyPos];\n                            g += buf2[xyPos+1];\n                            b += buf2[xyPos+2];\n                            a += buf2[xyPos+3];\n                        }\n                    }\n                    \n                    var pos = (i*wDst + j) * 4;\n                    bufDst[pos]   = Math.round(r / m);\n                    bufDst[pos+1] = Math.round(g / m);\n                    bufDst[pos+2] = Math.round(b / m);\n                    bufDst[pos+3] = Math.round(a / m);\n                }\n            }\n        } else {\n            // replace dst buffer with buf2\n            dst.data = buf2;\n        }\n    },\n    \n    bicubicInterpolation: function(src, dst, options) {\n        var interpolateCubic = function(x0, x1, x2, x3, t) {\n            var a0 = x3 - x2 - x0 + x1;\n            var a1 = x0 - x1 - a0;\n            var a2 = x2 - x0;\n            var a3 = x1;\n            return Math.max(0,Math.min(255,(a0 * (t * t * t)) + (a1 * (t * t)) + (a2 * t) + (a3)));\n        }\n        return this._interpolate2D(src, dst, options, interpolateCubic);\n    },\n    \n    hermiteInterpolation: function(src, dst, options) {\n        var interpolateHermite = function(x0, x1, x2, x3, t)\n        {\n            var c0 = x1;\n            var c1 = 0.5 * (x2 - x0);\n            var c2 = x0 - (2.5 * x1) + (2 * x2) - (0.5 * x3);\n            var c3 = (0.5 * (x3 - x0)) + (1.5 * (x1 - x2));\n            return  Math.max(0,Math.min(255,Math.round((((((c3 * t) + c2) * t) + c1) * t) + c0)));\n        }\n        return this._interpolate2D(src, dst, options, interpolateHermite);\n    },\n    \n    bezierInterpolation: function(src, dst, options) {\n        // between 2 points y(n), y(n+1), use next points out, y(n-1), y(n+2)\n        // to predict control points (a & b) to be placed at n+0.5\n        //  ya(n) = y(n) + (y(n+1)-y(n-1))/4\n        //  yb(n) = y(n+1) - (y(n+2)-y(n))/4\n        // then use std bezier to interpolate [n,n+1)\n        //  y(n+t) = y(n)*(1-t)^3 + 3 * ya(n)*(1-t)^2*t + 3 * yb(n)*(1-t)*t^2 + y(n+1)*t^3\n        //  note the 3* factor for the two control points\n        // for edge cases, can choose:\n        //  y(-1) = y(0) - 2*(y(1)-y(0))\n        //  y(w) = y(w-1) + 2*(y(w-1)-y(w-2))\n        // but can go with y(-1) = y(0) and y(w) = y(w-1)\n        var interpolateBezier = function(x0, x1, x2, x3, t) {\n            // x1, x2 are the knots, use x0 and x3 to calculate control points\n            var cp1 = x1 + (x2-x0)/4;\n            var cp2 = x2 - (x3-x1)/4;\n            var nt = 1-t;\n            var c0 =      x1 * nt * nt * nt;\n            var c1 = 3 * cp1 * nt * nt *  t;\n            var c2 = 3 * cp2 * nt *  t *  t;\n            var c3 =      x2 *  t *  t *  t;\n            return Math.max(0,Math.min(255,Math.round(c0 + c1 + c2 + c3)));\n        }\n        return this._interpolate2D(src, dst, options, interpolateBezier);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jimp/node_modules/jimp/phash.js":"/*\n\nCopyright (c) 2011 Elliot Shepherd\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\n// https://code.google.com/p/ironchef-team21/source/browse/ironchef_team21/src/ImagePHash.java\n\n/*\n * pHash-like image hash. \n * Author: Elliot Shepherd (elliot@jarofworms.com\n * Based On: http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\n */\n\nfunction ImagePHash(size, smallerSize) {\n    this.size = this.size || size;\n    this.smallerSize = this.smallerSize || smallerSize;\n    initCoefficients(this.size);\n}\n\nImagePHash.prototype.size = 32;\nImagePHash.prototype.smallerSize = 8;\n\nImagePHash.prototype.distance = function(s1, s2) {\n    var counter = 0;\n    for (var k = 0; k < s1.length; k++) {\n        if (s1[k] != s2[k]) {\n            counter++;\n        }\n    }\n    return (counter / s1.length);\n}\n\n// Returns a 'binary string' (like. 001010111011100010) which is easy to do a hamming distance on. \nImagePHash.prototype.getHash = function(img) {\n    /* 1. Reduce size. \n     * Like Average Hash, pHash starts with a small image. \n     * However, the image is larger than 8x8; 32x32 is a good size. \n     * This is really done to simplify the DCT computation and not \n     * because it is needed to reduce the high frequencies.\n     */\n    img = img.clone().resize(this.size, this.size);\n\n    /* 2. Reduce color. \n     * The image is reduced to a grayscale just to further simplify \n     * the number of computations.\n     */\n    img.grayscale();\n\n    var vals = [];\n\n    for (var x = 0; x < img.bitmap.width; x++) {\n        vals[x] = [];\n        for (var y = 0; y < img.bitmap.height; y++) {\n            vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;\n        }\n    }\n\n    /* 3. Compute the DCT. \n     * The DCT separates the image into a collection of frequencies \n     * and scalars. While JPEG uses an 8x8 DCT, this algorithm uses \n     * a 32x32 DCT.\n     */\n    var dctVals = applyDCT(vals, this.size);\n\n    /* 4. Reduce the DCT. \n     * This is the magic step. While the DCT is 32x32, just keep the \n     * top-left 8x8. Those represent the lowest frequencies in the \n     * picture.\n     */\n    /* 5. Compute the average value. \n     * Like the Average Hash, compute the mean DCT value (using only \n     * the 8x8 DCT low-frequency values and excluding the first term \n     * since the DC coefficient can be significantly different from \n     * the other values and will throw off the average).\n     */\n    var total = 0;\n\n    for (var x = 0; x < this.smallerSize; x++) {\n        for (var y = 0; y < this.smallerSize; y++) {\n            total += dctVals[x][y];\n        }\n    }\n\n    var avg = total / (this.smallerSize * this.smallerSize);\n\n    /* 6. Further reduce the DCT. \n     * This is the magic step. Set the 64 hash bits to 0 or 1 \n     * depending on whether each of the 64 DCT values is above or \n     * below the average value. The result doesn't tell us the \n     * actual low frequencies; it just tells us the very-rough \n     * relative scale of the frequencies to the mean. The result \n     * will not vary as long as the overall structure of the image \n     * remains the same; this can survive gamma and color histogram \n     * adjustments without a problem.\n     */\n    var hash = \"\";\n\n\tvar count = 0;\n    for (var x = 0; x < this.smallerSize; x++) {\n        for (var y = 0; y < this.smallerSize; y++) {\n            hash += (dctVals[x][y] > avg?\"1\":\"0\");\n        }\n    }\n\n    return hash;\n}\n\n// DCT function stolen from http://stackoverflow.com/questions/4240490/problems-with-dct-and-idct-algorithm-in-java\n\nfunction intToRGBA(i){\n    var rgba = {}\n    rgba.r = Math.floor(i / Math.pow(256, 3));\n    rgba.g = Math.floor((i - (rgba.r * Math.pow(256, 3))) / Math.pow(256, 2));\n    rgba.b = Math.floor((i - (rgba.r * Math.pow(256, 3)) - (rgba.g * Math.pow(256, 2))) / Math.pow(256, 1));\n    rgba.a = Math.floor((i - (rgba.r * Math.pow(256, 3)) - (rgba.g * Math.pow(256, 2)) - (rgba.b * Math.pow(256, 1))) / Math.pow(256, 0));\n    \n    return rgba;\n}\n\nvar c = [];\nfunction initCoefficients(size) {\n    for (var i=1;i<size;i++) {\n        c[i]=1;\n    }\n    c[0]=1/Math.sqrt(2.0);\n}\n\nfunction applyDCT(f, size) {\n    var N = size;\n\n    var F = [];\n    for (var u=0;u<N;u++) {\n      F[u] = [];\n      for (var v=0;v<N;v++) {\n        var sum = 0;\n        for (var i=0;i<N;i++) {\n          for (var j=0;j<N;j++) {\n            sum+=Math.cos(((2*i+1)/(2.0*N))*u*Math.PI)*Math.cos(((2*j+1)/(2.0*N))*v*Math.PI)*(f[i][j]);\n          }\n        }\n        sum*=((c[u]*c[v])/4);\n        F[u][v] = sum;\n      }\n    }\n    return F;\n}\n\nmodule.exports = ImagePHash;","/home/travis/build/npmtest/node-npmtest-jimp/node_modules/jimp/server.js":"var express = require(\"express\");\nvar app = express();\n\napp.use(express.static(__dirname + '/browser'));\n\napp.listen(8080);\n\nconsole.log(\"Serving on http://127.0.0.1:8080\");\n"}